{"filter":false,"title":"applications.js","tooltip":"/studio/typeface/assets/js/applications.js","undoManager":{"stack":[[{"start":{"row":0,"column":0},"end":{"row":185,"column":0},"action":"remove","lines":["// width = verge.viewportW();","// height = verge.viewportH();","","// buildTess = function(width, height) {","//   // var counter = 0;","//   var svg;","//   var path, path2, path3;","//   var animate;","//   var points = 50;","//   var width = width,","//     height = height;","//   var vertices,","//     vertices2,","//     vertices3;","//   var point = [1, 1];","//   //setting x and y speed by % of viewport seems to give better performance then hard coded pixel amounts","//   var xVelocity = width * 0.002;","//   var yVelocity = height * 0.0025;","","//   loadVertices(points);","","//   function newVertices(points) {","//     return d3.range(points).map(function(d) {","//       return [Math.random() * width, Math.random() * height];","//     });","//   }","","//   var voronoi = d3.geom.voronoi()","//     .clipExtent([","//       [0, 0],","//       [width, height]","//     ]);","","//   function zoomView() {","//     var points = vertices.length;","//     var fontSize = parseInt($(\"div.top h1\").css(\"font-size\").split(\"px\")[0]);","//     if (points >= 20) {","//       points = points - 10;","//       $(\"div.top h1\").css(\"font-size\", fontSize + 10);","//     }","//     loadVertices(points);","//     render();","","//   };","","//   var drag = d3.behavior.drag()","//     .on(\"dragstart\", function() {","//       //clear auto calling animate when dragging begins","//       clearInterval(animate);","//     })","//     .on(\"drag\", function() {","//       //touch events","//       touchXY = [d3.event.x, d3.event.y];","//       point = touchXY;","//       render();","//     })","//     .on(\"dragend\", function() {","//       animate = setInterval(function() {","//         render();","//       }, 5);","//     })","","//   svg = d3.select(\"#chart\").append(\"svg\")","//     .attr(\"width\", width)","//     .attr(\"height\", height)","//     //remove the following listeners if you simply want animation and no interaction ","//     .on(\"mousemove\", function() {","//       //stop calling animate when mouse takes control","//       clearInterval(animate);","//       var mouseXY = d3.mouse(this);","//       point = mouseXY;","//       render();","//     })","//     .on(\"click\", function() {","//       var mouseXY = [d3.event.x, d3.event.y];","//       point = mouseXY;","//       //reduce number of nodes on screen to give illusion of zooming in","//       zoomView(point);","//     })","//     .on('mouseleave', function() {","//       //restart animation after mouse lives viewport","//       animate = setInterval(function() {","//         render();","//       }, 5);","//     })","//     .call(drag);","","//   path = svg.append(\"g\").selectAll(\"path\");","//   path2 = svg.append(\"g\").selectAll(\"path\");","//   path3 = svg.append(\"g\").selectAll(\"path\");","","//   svg.append(\"rect\")","//     .attr(\"width\", width)","//     .attr(\"height\", height);","","//   //kick off continuous animation... raising the interval will  trigger the browser to paint and actually reduce performance","//   animate = setInterval(function() {","//     render();","//   }, 5);","","//   function render() {","//     var crntX = point[0];","//     var crntY = point[1];","//     var newX, newY;","//     //if moving point is at the right or left edges switch x direction","//     if (crntX >= width || crntX <= 0) {","//       xVelocity *= -1;","//     }","//     //if moving point is at the top or bottom edges switch y direction","//     if (crntY >= height || crntY <= 0) {","//       yVelocity *= -1;","//     }","","//     newX = crntX + xVelocity;","//     newY = crntY + yVelocity;","","//     redraw([newX, newY]);","//     point = [newX, newY];","","//   }","","//   function loadVertices(points) {","//     vertices = newVertices(points);","//     vertices2 = newVertices(points);","//     vertices3 = newVertices(points);","//   };","","//   function redraw(mouseXY) {","//     vertices[0] = mouseXY;","//     path = path.data(voronoi(vertices), polygon);","//     path.exit().remove();","//     path.enter().append(\"path\")","//       .attr(\"d\", polygon);","//     path.order();","","//     vertices2[0] = mouseXY;","//     path2 = path2.data(voronoi(vertices2), polygon);","//     path2.exit().remove();","//     path2.enter().append(\"path\")","//       .attr(\"d\", polygon);","//     path2.order();","","//     vertices3[0] = mouseXY;","//     path3 = path3.data(voronoi(vertices3), polygon);","//     path3.exit().remove();","//     path3.enter().append(\"path\")","//       .attr(\"d\", polygon);","//     path3.order();","//   }","","//   function polygon(d) {","//     return \"M\" + d.join(\"L\") + \"Z\";","//   }","","//   function getRandom() {","//     return Math.random() * (10 - 3) + 3;","//   }","// };","","// buildTess(width, height)","","","","","","","","!function(a){function b(b,d){function e(){if(w){$canvas=a('<canvas class=\"pg-canvas\"></canvas>'),v.prepend($canvas),p=$canvas[0],q=p.getContext(\"2d\"),f();for(var b=Math.round(p.width*p.height/d.density),c=0;b>c;c++){var e=new l;e.setStackPos(c),x.push(e)}a(window).on(\"resize\",function(){h()}),a(document).on(\"mousemove\",function(a){y=a.pageX,z=a.pageY}),B&&!A&&window.addEventListener(\"deviceorientation\",function(){D=Math.min(Math.max(-event.beta,-30),30),C=Math.min(Math.max(-event.gamma,-30),30)},!0),g(),o(\"onInit\")}}function f(){p.width=v.width(),p.height=v.height(),q.fillStyle=d.dotColor,q.strokeStyle=d.lineColor,q.lineWidth=d.lineWidth}function g(){if(w){s=a(window).width(),t=a(window).height(),q.clearRect(0,0,p.width,p.height);for(var b=0;b<x.length;b++)x[b].updatePosition();for(var b=0;b<x.length;b++)x[b].draw();E||(r=requestAnimationFrame(g))}}function h(){for(f(),i=x.length-1;i>=0;i--)(x[i].position.x>v.width()||x[i].position.y>v.height())&&x.splice(i,1);var a=Math.round(p.width*p.height/d.density);if(a>x.length)for(;a>x.length;){var b=new l;x.push(b)}else a<x.length&&x.splice(a);for(i=x.length-1;i>=0;i--)x[i].setStackPos(i)}function j(){E=!0}function k(){E=!1,g()}function l(){switch(this.stackPos,this.active=!0,this.layer=Math.ceil(3*Math.random()),this.parallaxOffsetX=0,this.parallaxOffsetY=0,this.position={x:Math.ceil(Math.random()*p.width),y:Math.ceil(Math.random()*p.height)},this.speed={},d.directionX){case\"left\":this.speed.x=+(-d.maxSpeedX+Math.random()*d.maxSpeedX-d.minSpeedX).toFixed(2);break;case\"right\":this.speed.x=+(Math.random()*d.maxSpeedX+d.minSpeedX).toFixed(2);break;default:this.speed.x=+(-d.maxSpeedX/2+Math.random()*d.maxSpeedX).toFixed(2),this.speed.x+=this.speed.x>0?d.minSpeedX:-d.minSpeedX}switch(d.directionY){case\"up\":this.speed.y=+(-d.maxSpeedY+Math.random()*d.maxSpeedY-d.minSpeedY).toFixed(2);break;case\"down\":this.speed.y=+(Math.random()*d.maxSpeedY+d.minSpeedY).toFixed(2);break;default:this.speed.y=+(-d.maxSpeedY/2+Math.random()*d.maxSpeedY).toFixed(2),this.speed.x+=this.speed.y>0?d.minSpeedY:-d.minSpeedY}}function m(a,b){return b?void(d[a]=b):d[a]}function n(){v.find(\".pg-canvas\").remove(),o(\"onDestroy\"),v.removeData(\"plugin_\"+c)}function o(a){void 0!==d[a]&&d[a].call(u)}var p,q,r,s,t,u=b,v=a(b),w=!!document.createElement(\"canvas\").getContext,x=[],y=0,z=0,A=!navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i),B=!!window.DeviceOrientationEvent,C=0,D=0,E=!1;return d=a.extend({},a.fn[c].defaults,d),l.prototype.draw=function(){q.beginPath(),q.arc(this.position.x+this.parallaxOffsetX,this.position.y+this.parallaxOffsetY,d.particleRadius/2,0,2*Math.PI,!0),q.closePath(),q.fill(),q.beginPath();for(var a=x.length-1;a>this.stackPos;a--){var b=x[a],c=this.position.x-b.position.x,e=this.position.y-b.position.y,f=Math.sqrt(c*c+e*e).toFixed(2);f<d.proximity&&(q.moveTo(this.position.x+this.parallaxOffsetX,this.position.y+this.parallaxOffsetY),d.curvedLines?q.quadraticCurveTo(Math.max(b.position.x,b.position.x),Math.min(b.position.y,b.position.y),b.position.x+b.parallaxOffsetX,b.position.y+b.parallaxOffsetY):q.lineTo(b.position.x+b.parallaxOffsetX,b.position.y+b.parallaxOffsetY))}q.stroke(),q.closePath()},l.prototype.updatePosition=function(){if(d.parallax){if(B&&!A){var a=(s-0)/60;pointerX=(C- -30)*a+0;var b=(t-0)/60;pointerY=(D- -30)*b+0}else pointerX=y,pointerY=z;this.parallaxTargX=(pointerX-s/2)/(d.parallaxMultiplier*this.layer),this.parallaxOffsetX+=(this.parallaxTargX-this.parallaxOffsetX)/10,this.parallaxTargY=(pointerY-t/2)/(d.parallaxMultiplier*this.layer),this.parallaxOffsetY+=(this.parallaxTargY-this.parallaxOffsetY)/10}switch(d.directionX){case\"left\":this.position.x+this.speed.x+this.parallaxOffsetX<0&&(this.position.x=v.width()-this.parallaxOffsetX);break;case\"right\":this.position.x+this.speed.x+this.parallaxOffsetX>v.width()&&(this.position.x=0-this.parallaxOffsetX);break;default:(this.position.x+this.speed.x+this.parallaxOffsetX>v.width()||this.position.x+this.speed.x+this.parallaxOffsetX<0)&&(this.speed.x=-this.speed.x)}switch(d.directionY){case\"up\":this.position.y+this.speed.y+this.parallaxOffsetY<0&&(this.position.y=v.height()-this.parallaxOffsetY);break;case\"down\":this.position.y+this.speed.y+this.parallaxOffsetY>v.height()&&(this.position.y=0-this.parallaxOffsetY);break;default:(this.position.y+this.speed.y+this.parallaxOffsetY>v.height()||this.position.y+this.speed.y+this.parallaxOffsetY<0)&&(this.speed.y=-this.speed.y)}this.position.x+=this.speed.x,this.position.y+=this.speed.y},l.prototype.setStackPos=function(a){this.stackPos=a},e(),{option:m,destroy:n,start:k,pause:j}}var c=\"particleground\";a.fn[c]=function(d){if(\"string\"==typeof arguments[0]){var e,f=arguments[0],g=Array.prototype.slice.call(arguments,1);return this.each(function(){a.data(this,\"plugin_\"+c)&&\"function\"==typeof a.data(this,\"plugin_\"+c)[f]&&(e=a.data(this,\"plugin_\"+c)[f].apply(this,g))}),void 0!==e?e:this}return\"object\"!=typeof d&&d?void 0:this.each(function(){a.data(this,\"plugin_\"+c)||a.data(this,\"plugin_\"+c,new b(this,d))})},a.fn[c].defaults={minSpeedX:.1,maxSpeedX:.7,minSpeedY:.1,maxSpeedY:.7,directionX:\"center\",directionY:\"center\",density:1e4,dotColor:\"#666666\",lineColor:\"#666666\",particleRadius:7,lineWidth:1,curvedLines:!1,proximity:100,parallax:!0,parallaxMultiplier:5,onInit:function(){},onDestroy:function(){}}}(jQuery),/**"," * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel"," * @see: http://paulirish.com/2011/requestanimationframe-for-smart-animating/"," * @see: http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating"," * @license: MIT license"," */","function(){for(var a=0,b=[\"ms\",\"moz\",\"webkit\",\"o\"],c=0;c<b.length&&!window.requestAnimationFrame;++c)window.requestAnimationFrame=window[b[c]+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[b[c]+\"CancelAnimationFrame\"]||window[b[c]+\"CancelRequestAnimationFrame\"];window.requestAnimationFrame||(window.requestAnimationFrame=function(b){var c=(new Date).getTime(),d=Math.max(0,16-(c-a)),e=window.setTimeout(function(){b(c+d)},d);return a=c+d,e}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(a){clearTimeout(a)})}();","","jQuery(document).ready(function($) {","  $('body').particleground({","    dotColor: '#859398',","    lineColor: '#859398'","  });","});","","","","",""],"id":11}],[{"start":{"row":0,"column":0},"end":{"row":159,"column":24},"action":"insert","lines":["width = verge.viewportW();","height = verge.viewportH();","","buildTess = function(width, height) {","  // var counter = 0;","  var svg;","  var path, path2, path3;","  var animate;","  var points = 50;","  var width = width,","    height = height;","  var vertices,","    vertices2,","    vertices3;","  var point = [1, 1];","  //setting x and y speed by % of viewport seems to give better performance then hard coded pixel amounts","  var xVelocity = width * 0.002;","  var yVelocity = height * 0.0025;","","  loadVertices(points);","","  function newVertices(points) {","    return d3.range(points).map(function(d) {","      return [Math.random() * width, Math.random() * height];","    });","  }","","  var voronoi = d3.geom.voronoi()","    .clipExtent([","      [0, 0],","      [width, height]","    ]);","","  function zoomView() {","    var points = vertices.length;","    var fontSize = parseInt($(\"div.top h1\").css(\"font-size\").split(\"px\")[0]);","    if (points >= 20) {","      points = points - 10;","      $(\"div.top h1\").css(\"font-size\", fontSize + 10);","    }","    loadVertices(points);","    render();","","  };","","  var drag = d3.behavior.drag()","    .on(\"dragstart\", function() {","      //clear auto calling animate when dragging begins","      clearInterval(animate);","    })","    .on(\"drag\", function() {","      //touch events","      touchXY = [d3.event.x, d3.event.y];","      point = touchXY;","      render();","    })","    .on(\"dragend\", function() {","      animate = setInterval(function() {","        render();","      }, 5);","    })","","  svg = d3.select(\"#chart\").append(\"svg\")","    .attr(\"width\", width)","    .attr(\"height\", height)","    //remove the following listeners if you simply want animation and no interaction ","    .on(\"mousemove\", function() {","      //stop calling animate when mouse takes control","      clearInterval(animate);","      var mouseXY = d3.mouse(this);","      point = mouseXY;","      render();","    })","    .on(\"click\", function() {","      var mouseXY = [d3.event.x, d3.event.y];","      point = mouseXY;","      //reduce number of nodes on screen to give illusion of zooming in","      zoomView(point);","    })","    .on('mouseleave', function() {","      //restart animation after mouse lives viewport","      animate = setInterval(function() {","        render();","      }, 5);","    })","    .call(drag);","","  path = svg.append(\"g\").selectAll(\"path\");","  path2 = svg.append(\"g\").selectAll(\"path\");","  path3 = svg.append(\"g\").selectAll(\"path\");","","  svg.append(\"rect\")","    .attr(\"width\", width)","    .attr(\"height\", height);","","  //kick off continuous animation... raising the interval will  trigger the browser to paint and actually reduce performance","  animate = setInterval(function() {","    render();","  }, 5);","","  function render() {","    var crntX = point[0];","    var crntY = point[1];","    var newX, newY;","    //if moving point is at the right or left edges switch x direction","    if (crntX >= width || crntX <= 0) {","      xVelocity *= -1;","    }","    //if moving point is at the top or bottom edges switch y direction","    if (crntY >= height || crntY <= 0) {","      yVelocity *= -1;","    }","","    newX = crntX + xVelocity;","    newY = crntY + yVelocity;","","    redraw([newX, newY]);","    point = [newX, newY];","","  }","","  function loadVertices(points) {","    vertices = newVertices(points);","    vertices2 = newVertices(points);","    vertices3 = newVertices(points);","  };","","  function redraw(mouseXY) {","    vertices[0] = mouseXY;","    path = path.data(voronoi(vertices), polygon);","    path.exit().remove();","    path.enter().append(\"path\")","      .attr(\"d\", polygon);","    path.order();","","    vertices2[0] = mouseXY;","    path2 = path2.data(voronoi(vertices2), polygon);","    path2.exit().remove();","    path2.enter().append(\"path\")","      .attr(\"d\", polygon);","    path2.order();","","    vertices3[0] = mouseXY;","    path3 = path3.data(voronoi(vertices3), polygon);","    path3.exit().remove();","    path3.enter().append(\"path\")","      .attr(\"d\", polygon);","    path3.order();","  }","","  function polygon(d) {","    return \"M\" + d.join(\"L\") + \"Z\";","  }","","  function getRandom() {","    return Math.random() * (10 - 3) + 3;","  }","};","","buildTess(width, height)"],"id":12}],[{"start":{"row":143,"column":4},"end":{"row":143,"column":7},"action":"insert","lines":["// "],"id":13}],[{"start":{"row":0,"column":0},"end":{"row":0,"column":3},"action":"insert","lines":["// "],"id":14}],[{"start":{"row":1,"column":0},"end":{"row":1,"column":3},"action":"insert","lines":["// "],"id":15}],[{"start":{"row":159,"column":0},"end":{"row":159,"column":3},"action":"insert","lines":["// "],"id":16}],[{"start":{"row":0,"column":0},"end":{"row":159,"column":27},"action":"remove","lines":["// width = verge.viewportW();","// height = verge.viewportH();","","buildTess = function(width, height) {","  // var counter = 0;","  var svg;","  var path, path2, path3;","  var animate;","  var points = 50;","  var width = width,","    height = height;","  var vertices,","    vertices2,","    vertices3;","  var point = [1, 1];","  //setting x and y speed by % of viewport seems to give better performance then hard coded pixel amounts","  var xVelocity = width * 0.002;","  var yVelocity = height * 0.0025;","","  loadVertices(points);","","  function newVertices(points) {","    return d3.range(points).map(function(d) {","      return [Math.random() * width, Math.random() * height];","    });","  }","","  var voronoi = d3.geom.voronoi()","    .clipExtent([","      [0, 0],","      [width, height]","    ]);","","  function zoomView() {","    var points = vertices.length;","    var fontSize = parseInt($(\"div.top h1\").css(\"font-size\").split(\"px\")[0]);","    if (points >= 20) {","      points = points - 10;","      $(\"div.top h1\").css(\"font-size\", fontSize + 10);","    }","    loadVertices(points);","    render();","","  };","","  var drag = d3.behavior.drag()","    .on(\"dragstart\", function() {","      //clear auto calling animate when dragging begins","      clearInterval(animate);","    })","    .on(\"drag\", function() {","      //touch events","      touchXY = [d3.event.x, d3.event.y];","      point = touchXY;","      render();","    })","    .on(\"dragend\", function() {","      animate = setInterval(function() {","        render();","      }, 5);","    })","","  svg = d3.select(\"#chart\").append(\"svg\")","    .attr(\"width\", width)","    .attr(\"height\", height)","    //remove the following listeners if you simply want animation and no interaction ","    .on(\"mousemove\", function() {","      //stop calling animate when mouse takes control","      clearInterval(animate);","      var mouseXY = d3.mouse(this);","      point = mouseXY;","      render();","    })","    .on(\"click\", function() {","      var mouseXY = [d3.event.x, d3.event.y];","      point = mouseXY;","      //reduce number of nodes on screen to give illusion of zooming in","      zoomView(point);","    })","    .on('mouseleave', function() {","      //restart animation after mouse lives viewport","      animate = setInterval(function() {","        render();","      }, 5);","    })","    .call(drag);","","  path = svg.append(\"g\").selectAll(\"path\");","  path2 = svg.append(\"g\").selectAll(\"path\");","  path3 = svg.append(\"g\").selectAll(\"path\");","","  svg.append(\"rect\")","    .attr(\"width\", width)","    .attr(\"height\", height);","","  //kick off continuous animation... raising the interval will  trigger the browser to paint and actually reduce performance","  animate = setInterval(function() {","    render();","  }, 5);","","  function render() {","    var crntX = point[0];","    var crntY = point[1];","    var newX, newY;","    //if moving point is at the right or left edges switch x direction","    if (crntX >= width || crntX <= 0) {","      xVelocity *= -1;","    }","    //if moving point is at the top or bottom edges switch y direction","    if (crntY >= height || crntY <= 0) {","      yVelocity *= -1;","    }","","    newX = crntX + xVelocity;","    newY = crntY + yVelocity;","","    redraw([newX, newY]);","    point = [newX, newY];","","  }","","  function loadVertices(points) {","    vertices = newVertices(points);","    vertices2 = newVertices(points);","    vertices3 = newVertices(points);","  };","","  function redraw(mouseXY) {","    vertices[0] = mouseXY;","    path = path.data(voronoi(vertices), polygon);","    path.exit().remove();","    path.enter().append(\"path\")","      .attr(\"d\", polygon);","    path.order();","","    vertices2[0] = mouseXY;","    path2 = path2.data(voronoi(vertices2), polygon);","    path2.exit().remove();","    path2.enter().append(\"path\")","      .attr(\"d\", polygon);","    path2.order();","","    vertices3[0] = mouseXY;","    // path3 = path3.data(voronoi(vertices3), polygon);","    path3.exit().remove();","    path3.enter().append(\"path\")","      .attr(\"d\", polygon);","    path3.order();","  }","","  function polygon(d) {","    return \"M\" + d.join(\"L\") + \"Z\";","  }","","  function getRandom() {","    return Math.random() * (10 - 3) + 3;","  }","};","","// buildTess(width, height)"],"id":17},{"start":{"row":0,"column":0},"end":{"row":2804,"column":2},"action":"insert","lines":["/*","    ***** BEGIN LICENSE BLOCK *****","    ","    Copyright © 2009 Center for History and New Media","                     George Mason University, Fairfax, Virginia, USA","                     http://zotero.org","    ","    This file is part of Zotero.","    ","    Zotero is free software: you can redistribute it and/or modify","    it under the terms of the GNU Affero General Public License as published by","    the Free Software Foundation, either version 3 of the License, or","    (at your option) any later version.","    ","    Zotero is distributed in the hope that it will be useful,","    but WITHOUT ANY WARRANTY; without even the implied warranty of","    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the","    GNU Affero General Public License for more details.","    ","    You should have received a copy of the GNU Affero General Public License","    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.","    ","    ***** END LICENSE BLOCK *****","*/","","/**"," * @class"," * Deprecated class for creating new Zotero.Translate instances<br/>"," * <br/>"," * New code should use Zotero.Translate.Web, Zotero.Translate.Import, Zotero.Translate.Export, or"," * Zotero.Translate.Search"," */","Zotero.Translate = function(type) {","\tZotero.debug(\"Translate: WARNING: new Zotero.Translate() is deprecated; please don't use this if you don't have to\");","\t// hack","\tvar translate = Zotero.Translate.newInstance(type);","\tfor(var i in translate) {","\t\tthis[i] = translate[i];","\t}","\tthis.constructor = translate.constructor;","\tthis.__proto__ = translate.__proto__;","}","","/**"," * Create a new translator by a string type"," */","Zotero.Translate.newInstance = function(type) {","\treturn new Zotero.Translate[type.substr(0, 1).toUpperCase()+type.substr(1).toLowerCase()];","}","","/**"," * Namespace for Zotero sandboxes"," * @namespace"," */","Zotero.Translate.Sandbox = {","\t/**","\t * Combines a sandbox with the base sandbox","\t */","\t\"_inheritFromBase\":function(sandboxToMerge) {","\t\tvar newSandbox = {};","\t\t","\t\tfor(var method in Zotero.Translate.Sandbox.Base) {","\t\t\tnewSandbox[method] = Zotero.Translate.Sandbox.Base[method];","\t\t}","\t\t","\t\tfor(var method in sandboxToMerge) {","\t\t\tnewSandbox[method] = sandboxToMerge[method];","\t\t}","\t\t","\t\treturn newSandbox;","\t},","\t","\t/**","\t * Base sandbox. These methods are available to all translators.","\t * @namespace","\t */","\t\"Base\": {","\t\t/**","\t\t * Called as {@link Zotero.Item#complete} from translators to save items to the database.","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox","\t\t */","\t\t\"_itemDone\":function(translate, item) {","\t\t\t//Zotero.debug(\"Translate: Saving item\");","\t\t\t","\t\t\t// warn if itemDone called after translation completed","\t\t\tif(translate._complete) {","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.Item#complete() called after Zotero.done(); please fix your code\", 2);","\t\t\t}","\t\t\t\t","\t\t\tconst allowedObjects = [\"complete\", \"attachments\", \"seeAlso\", \"creators\", \"tags\", \"notes\"];","\t\t\t","\t\t\tdelete item.complete;","\t\t\tfor(var i in item) {","\t\t\t\tvar val = item[i];","\t\t\t\tif(!val && val !== 0) {","\t\t\t\t\t// remove null, undefined, and false properties, and convert objects to strings","\t\t\t\t\tdelete item[i];","\t\t\t\t\tcontinue;","\t\t\t\t}","\t\t\t\t","\t\t\t\tvar type = typeof val;","\t\t\t\tvar isObject = type === \"object\" || type === \"xml\" || type === \"function\",","\t\t\t\t\tshouldBeObject = allowedObjects.indexOf(i) !== -1;","\t\t\t\tif(isObject && !shouldBeObject) {","\t\t\t\t\t// Convert things that shouldn't be objects to objects","\t\t\t\t\ttranslate._debug(\"Translate: WARNING: typeof \"+i+\" is \"+type+\"; converting to string\");","\t\t\t\t\titem[i] = val.toString();","\t\t\t\t} else if(shouldBeObject && !isObject) {","\t\t\t\t\ttranslate._debug(\"Translate: WARNING: typeof \"+i+\" is \"+type+\"; converting to array\");","\t\t\t\t\titem[i] = [val];","\t\t\t\t} else if(type === \"string\") {","\t\t\t\t\t// trim strings","\t\t\t\t\titem[i] = val.trim();","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\t// if we're not supposed to save the item or we're in a child translator,","\t\t\t// just return the item array","\t\t\tif(translate._libraryID === false || translate._parentTranslator) {","\t\t\t\ttranslate.newItems.push(item);","\t\t\t\ttranslate._runHandler(\"itemDone\", item, item);","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\t// We use this within the connector to keep track of items as they are saved","\t\t\tif(!item.id) item.id = Zotero.Utilities.randomString();","\t\t\t","\t\t\t// don't save documents as documents in connector, since we can't pass them around","\t\t\tif(Zotero.isConnector) {","\t\t\t\tvar attachments = item.attachments;","\t\t\t\tvar nAttachments = attachments.length;","\t\t\t\tfor(var j=0; j<nAttachments; j++) {","\t\t\t\t\tif(attachments[j].document) {","\t\t\t\t\t\tattachments[j].url = attachments[j].document.documentURI || attachments[j].document.URL;","\t\t\t\t\t\tattachments[j].mimeType = \"text/html\";","\t\t\t\t\t\tdelete attachments[j].document;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t","\t\t\t// Fire itemSaving event","\t\t\ttranslate._runHandler(\"itemSaving\", item);","\t\t\t","\t\t\tif(translate instanceof Zotero.Translate.Web) {","\t\t\t\t// For web translators, we queue saves","\t\t\t\ttranslate.saveQueue.push(item);","\t\t\t} else {","\t\t\t\t// Save items","\t\t\t\ttranslate._saveItems([item]);","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Gets translator options that were defined in displayOptions in translator header","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} option Option to be retrieved","\t\t */","\t\t\"getOption\":function(translate, option) {","\t\t\tif(typeof option !== \"string\") {","\t\t\t\tthrow(new Error(\"getOption: option must be a string\"));","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\treturn translate._displayOptions[option];","\t\t},","\t\t","\t\t/**","\t\t * Gets a hidden preference that can be defined by hiddenPrefs in translator header","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} pref Prefernce to be retrieved","\t\t */","\t\t\"getHiddenPref\":function(translate, pref) {","\t\t\tif(typeof(pref) != \"string\") {","\t\t\t\tthrow(new Error(\"getPref: preference must be a string\"));","\t\t\t}","","\t\t\tvar hp = translate._translatorInfo.hiddenPrefs || {};","","\t\t\tvar value;","\t\t\ttry {","\t\t\t\tvalue = Zotero.Prefs.get('translators.' + pref);","\t\t\t} catch(e) {}","","\t\t\treturn (value !== undefined ? value : hp[pref]);","\t\t},","\t\t","\t\t/**","\t\t * For loading other translators and accessing their methods","\t\t * ","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} type Translator type (\"web\", \"import\", \"export\", or \"search\")","\t\t * @returns {Object} A safeTranslator object, which operates mostly like Zotero.Translate","\t\t */\t ","\t\t\"loadTranslator\":function(translate, type) {","\t\t\tconst setDefaultHandlers = function(translate, translation) {","\t\t\t\tif(type !== \"export\"","\t\t\t\t\t&& (!translation._handlers['itemDone'] || !translation._handlers['itemDone'].length)) {","\t\t\t\t\ttranslation.setHandler(\"itemDone\", function(obj, item) {","\t\t\t\t\t\ttranslate.Sandbox._itemDone(translate, item);","\t\t\t\t\t});","\t\t\t\t}","\t\t\t\tif(!translation._handlers['selectItems'] || !translation._handlers['selectItems'].length) {","\t\t\t\t\ttranslation.setHandler(\"selectItems\", translate._handlers[\"selectItems\"]);","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\tif(typeof type !== \"string\") {","\t\t\t\tthrow(new Error(\"loadTranslator: type must be a string\"));","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\tZotero.debug(\"Translate: Creating translate instance of type \"+type+\" in sandbox\");","\t\t\tvar translation = Zotero.Translate.newInstance(type);","\t\t\ttranslation._parentTranslator = translate;","\t\t\t","\t\t\tif(translation instanceof Zotero.Translate.Export && !(translation instanceof Zotero.Translate.Export)) {","\t\t\t\tthrow(new Error(\"Only export translators may call other export translators\"));","\t\t\t}","\t\t\t","\t\t\t/**","\t\t\t * @class Wrapper for {@link Zotero.Translate} for safely calling another translator ","\t\t\t * from inside an existing translator","\t\t\t * @inner","\t\t\t */","\t\t\tvar safeTranslator = {};","\t\t\tsafeTranslator.__exposedProps__ = {","\t\t\t\t\"setSearch\":\"r\",","\t\t\t\t\"setDocument\":\"r\",","\t\t\t\t\"setHandler\":\"r\",","\t\t\t\t\"setString\":\"r\",","\t\t\t\t\"setTranslator\":\"r\",","\t\t\t\t\"getTranslators\":\"r\",","\t\t\t\t\"translate\":\"r\",","\t\t\t\t\"getTranslatorObject\":\"r\"","\t\t\t};","\t\t\tsafeTranslator.setSearch = function(arg) {","\t\t\t\tif(!Zotero.isBookmarklet) arg = JSON.parse(JSON.stringify(arg));","\t\t\t\treturn translation.setSearch(arg);","\t\t\t};","\t\t\tsafeTranslator.setDocument = function(arg) {","\t\t\t\tif (Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\tif (arg.wrappedJSObject && arg.wrappedJSObject.__wrappedObject) {","\t\t\t\t\t\targ = arg.wrappedJSObject.__wrappedObject;","\t\t\t\t\t}","\t\t\t\t\treturn translation.setDocument(new XPCNativeWrapper(arg));","\t\t\t\t} else {","\t\t\t\t\treturn translation.setDocument(arg);","\t\t\t\t}","\t\t\t};","\t\t\tvar errorHandlerSet = false;","\t\t\tsafeTranslator.setHandler = function(arg1, arg2) {","\t\t\t\tif(arg1 === \"error\") errorHandlerSet = true;","\t\t\t\ttranslation.setHandler(arg1, ","\t\t\t\t\tfunction(obj, item) {","\t\t\t\t\t\ttry {","\t\t\t\t\t\t\titem = item.wrappedJSObject ? item.wrappedJSObject : item;","\t\t\t\t\t\t\tif(arg1 == \"itemDone\") {","\t\t\t\t\t\t\t\titem.complete = translate._sandboxZotero.Item.prototype.complete;","\t\t\t\t\t\t\t} else if(arg1 == \"translators\" && Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\t\t\t\tvar translators = new translate._sandboxManager.sandbox.Array();","\t\t\t\t\t\t\t\ttranslators = translators.wrappedJSObject || translators;","\t\t\t\t\t\t\t\tfor (var i=0; i<item.length; i++) {","\t\t\t\t\t\t\t\t\ttranslators.push(item[i]);","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\titem = translators;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\targ2(obj, item);","\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\ttranslate.complete(false, e);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t);","\t\t\t};","\t\t\tsafeTranslator.setString = function(arg) { translation.setString(arg) };","\t\t\tsafeTranslator.setTranslator = function(arg) {","\t\t\t\tvar success = translation.setTranslator(arg);","\t\t\t\tif(!success) {","\t\t\t\t\tthrow new Error(\"Translator \"+translate.translator[0].translatorID+\" attempted to call invalid translatorID \"+arg);","\t\t\t\t}","\t\t\t};","\t\t\t","\t\t\tvar translatorsHandlerSet = false;","\t\t\tsafeTranslator.getTranslators = function() {","\t\t\t\tif(!translation._handlers[\"translators\"] || !translation._handlers[\"translators\"].length) {","\t\t\t\t\tif(Zotero.isConnector) {","\t\t\t\t\t\tthrow new Error('Translator must register a \"translators\" handler to '+","\t\t\t\t\t\t\t'call getTranslators() in this translation environment.');","\t\t\t\t\t} else {","\t\t\t\t\t\ttranslate._debug('COMPAT WARNING: Translator must register a \"translators\" handler to '+","\t\t\t\t\t\t\t'call getTranslators() in connector');","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif(!translatorsHandlerSet) {","\t\t\t\t\ttranslation.setHandler(\"translators\", function() {","\t\t\t\t\t\ttranslate.decrementAsyncProcesses(\"safeTranslator#getTranslators()\");","\t\t\t\t\t});","\t\t\t\t}","\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#getTranslators()\");","\t\t\t\treturn translation.getTranslators();","\t\t\t};","\t\t\t","\t\t\tvar doneHandlerSet = false;","\t\t\tsafeTranslator.translate = function() {","\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#translate()\");","\t\t\t\tsetDefaultHandlers(translate, translation);","\t\t\t\tif(!doneHandlerSet) {","\t\t\t\t\tdoneHandlerSet = true;","\t\t\t\t\ttranslation.setHandler(\"done\", function() { translate.decrementAsyncProcesses(\"safeTranslator#translate()\") });","\t\t\t\t}","\t\t\t\tif(!errorHandlerSet) {","\t\t\t\t\terrorHandlerSet = true;","\t\t\t\t\ttranslation.setHandler(\"error\", function(obj, error) { translate.complete(false, error) });","\t\t\t\t}","\t\t\t\treturn translation.translate(false);","\t\t\t};","\t\t\t","\t\t\tsafeTranslator.getTranslatorObject = function(callback) {","\t\t\t\tif(callback) {","\t\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#getTranslatorObject()\");","\t\t\t\t} else {","\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: Translator must pass a callback to getTranslatorObject() to operate in connector\");","\t\t\t\t}","\t\t\t\t","\t\t\t\tvar sandbox;","\t\t\t\tvar haveTranslatorFunction = function(translator) {","\t\t\t\t\ttranslation.translator[0] = translator;","\t\t\t\t\ttranslation._loadTranslator(translator, function() {","\t\t\t\t\t\tif(Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\t\t\t// do same origin check","\t\t\t\t\t\t\tvar secMan = Components.classes[\"@mozilla.org/scriptsecuritymanager;1\"]","\t\t\t\t\t\t\t\t.getService(Components.interfaces.nsIScriptSecurityManager);","\t\t\t\t\t\t\tvar ioService = Components.classes[\"@mozilla.org/network/io-service;1\"] ","\t\t\t\t\t\t\t\t.getService(Components.interfaces.nsIIOService);","\t\t\t\t\t\t\t","\t\t\t\t\t\t\tvar outerSandboxURI = ioService.newURI(typeof translate._sandboxLocation === \"object\" ?","\t\t\t\t\t\t\t\ttranslate._sandboxLocation.location : translate._sandboxLocation, null, null);","\t\t\t\t\t\t\tvar innerSandboxURI = ioService.newURI(typeof translation._sandboxLocation === \"object\" ?","\t\t\t\t\t\t\t\ttranslation._sandboxLocation.location : translation._sandboxLocation, null, null);","\t\t\t\t\t\t\t","\t\t\t\t\t\t\ttry {","\t\t\t\t\t\t\t\tsecMan.checkSameOriginURI(outerSandboxURI, innerSandboxURI, false);","\t\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\t\tthrow new Error(\"getTranslatorObject() may not be called from web or search \"+","\t\t\t\t\t\t\t\t\t\"translators to web or search translators from different origins.\");","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\t","\t\t\t\t\t\ttranslation._prepareTranslation();","\t\t\t\t\t\tsetDefaultHandlers(translate, translation);","\t\t\t\t\t\tsandbox = translation._sandboxManager.sandbox;","\t\t\t\t\t\tif(!Zotero.Utilities.isEmpty(sandbox.exports)) {","\t\t\t\t\t\t\tsandbox.exports.Zotero = sandbox.Zotero;","\t\t\t\t\t\t\tsandbox = sandbox.exports;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: \"+translation.translator[0].label+\" does \"+","\t\t\t\t\t\t\t\t\"not export any properties. Only detect\"+translation._entryFunctionSuffix+","\t\t\t\t\t\t\t\t\" and do\"+translation._entryFunctionSuffix+\" will be available in \"+","\t\t\t\t\t\t\t\t\"connectors.\");","\t\t\t\t\t\t}","\t\t\t\t\t\t","\t\t\t\t\t\tif(callback) {","\t\t\t\t\t\t\ttry {","\t\t\t\t\t\t\t\tcallback(sandbox);","\t\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\t\ttranslate.complete(false, e);","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\ttranslate.decrementAsyncProcesses(\"safeTranslator#getTranslatorObject()\");","\t\t\t\t\t\t}","\t\t\t\t\t});","\t\t\t\t};","\t\t\t\t","\t\t\t\tif(typeof translation.translator[0] === \"object\") {","\t\t\t\t\thaveTranslatorFunction(translation.translator[0]);","\t\t\t\t\treturn translation._sandboxManager.sandbox;","\t\t\t\t} else {","\t\t\t\t\tif(Zotero.isConnector && (!Zotero.isFx || Zotero.isBookmarklet) && !callback) {","\t\t\t\t\t\tthrow new Error(\"Translator must pass a callback to getTranslatorObject() to \"+","\t\t\t\t\t\t\t\"operate in this translation environment.\");","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tZotero.Translators.get(translation.translator[0], haveTranslatorFunction);","\t\t\t\t\tif(Zotero.isConnector && Zotero.isFx && !callback) {","\t\t\t\t\t\twhile(!sandbox && translate._currentState) {","\t\t\t\t\t\t\t// This processNextEvent call is used to handle a deprecated case","\t\t\t\t\t\t\tZotero.mainThread.processNextEvent(true);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tif(sandbox) return sandbox;","\t\t\t\t}","\t\t\t};","","\t\t\tif(Zotero.isFx && Zotero.platformMajorVersion >= 33) {","\t\t\t\tfor(var i in safeTranslator) {","\t\t\t\t\tif (typeof(safeTranslator[i]) === \"function\") {","\t\t\t\t\t\tsafeTranslator[i] = translate._sandboxManager._makeContentForwarder(function(func) {","\t\t\t\t\t\t\treturn function() {","\t\t\t\t\t\t\t\tfunc.apply(safeTranslator, this.args.wrappedJSObject || this.args);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}(safeTranslator[i]));","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\treturn safeTranslator;","\t\t},","\t\t","\t\t/**","\t\t * Enables asynchronous detection or translation","\t\t * @param {Zotero.Translate} translate","\t\t * @deprecated","\t\t */","\t\t\"wait\":function(translate) {},","\t\t","\t\t/**","\t\t * Sets the return value for detection","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t */","\t\t\"done\":function(translate, returnValue) {","\t\t\tif(translate._currentState === \"detect\") {","\t\t\t\ttranslate._returnValue = returnValue;","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Proxy for translator _debug function","\t\t * ","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} string String to write to console","\t\t * @param {String} [level] Level to log as (1 to 5)","\t\t */","\t\t\"debug\":function(translate, string, level) {","\t\t\ttranslate._debug(string, level);","\t\t}","\t},","\t","\t/**","\t * Web functions exposed to sandbox","\t * @namespace","\t */","\t\"Web\":{","\t\t/**","\t\t * Lets user pick which items s/he wants to put in his/her library","\t\t * @param {Zotero.Translate} translate","\t\t * @param {Object} items An set of id => name pairs in object format","\t\t */","\t\t\"selectItems\":function(translate, items, callback) {","\t\t\tfunction transferObject(obj) {","\t\t\t\treturn Zotero.isFx ? translate._sandboxManager.copyObject(obj) : obj;","\t\t\t}","\t\t\t","\t\t\tif(Zotero.Utilities.isEmpty(items)) {","\t\t\t\tthrow new Error(\"Translator called select items with no items\");","\t\t\t}","\t\t\t","\t\t\t// Some translators pass an array rather than an object to Zotero.selectItems.","\t\t\t// This will break messaging outside of Firefox, so we need to fix it.","\t\t\tif(Object.prototype.toString.call(items) === \"[object Array]\") {","\t\t\t\ttranslate._debug(\"WARNING: Zotero.selectItems should be called with an object, not an array\");","\t\t\t\tvar itemsObj = {};","\t\t\t\tfor(var i in items) itemsObj[i] = items[i];","\t\t\t\titems = itemsObj;","\t\t\t}","\t\t\t","\t\t\tif(translate._selectedItems) {","\t\t\t\t// if we have a set of selected items for this translation, use them","\t\t\t\treturn transferObject(translate._selectedItems);","\t\t\t} else if(translate._handlers.select) {","\t\t\t\t\t// whether the translator supports asynchronous selectItems","\t\t\t\t\tvar haveAsyncCallback = !!callback;","\t\t\t\t\t// whether the handler operates asynchronously","\t\t\t\t\tvar haveAsyncHandler = false;","\t\t\t\t\tvar returnedItems = null;","\t\t\t\t\t","\t\t\t\t\tvar callbackExecuted = false;","\t\t\t\t\tif(haveAsyncCallback) {","\t\t\t\t\t\t// if this translator provides an async callback for selectItems, rig things","\t\t\t\t\t\t// up to pop off the async process","\t\t\t\t\t\tvar newCallback = function(selectedItems) {","\t\t\t\t\t\t\tcallbackExecuted = true;","\t\t\t\t\t\t\tcallback(transferObject(selectedItems));","\t\t\t\t\t\t\tif(haveAsyncHandler) translate.decrementAsyncProcesses(\"Zotero.selectItems()\");","\t\t\t\t\t\t};","\t\t\t\t\t} else {","\t\t\t\t\t\t// if this translator doesn't provide an async callback for selectItems, set things","\t\t\t\t\t\t// up so that we can wait to see if the select handler returns synchronously. If it","\t\t\t\t\t\t// doesn't, we will need to restart translation.","\t\t\t\t\t\tvar newCallback = function(selectedItems) {","\t\t\t\t\t\t\tcallbackExecuted = true;","\t\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t\ttranslate.translate(translate._libraryID, translate._saveAttachments, selectedItems);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\treturnedItems = transferObject(selectedItems);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t};","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tvar returnValue = translate._runHandler(\"select\", items, newCallback);","\t\t\t\t\tif(returnValue !== undefined) {","\t\t\t\t\t\t// handler may have returned a value, which makes callback unnecessary","\t\t\t\t\t\tZotero.debug(\"WARNING: Returning items from a select handler is deprecated. \"+","\t\t\t\t\t\t\t\"Please pass items as to the callback provided as the third argument to \"+","\t\t\t\t\t\t\t\"the handler.\");","\t\t\t\t\t\t","\t\t\t\t\t\treturnedItems = transferObject(returnValue);","\t\t\t\t\t\thaveAsyncHandler = false;","\t\t\t\t\t} else {","\t\t\t\t\t\t// if we don't have returnedItems set already, the handler is asynchronous","\t\t\t\t\t\thaveAsyncHandler = !callbackExecuted;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(haveAsyncCallback) {","\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t// we are running asynchronously, so increment async processes","\t\t\t\t\t\t\ttranslate.incrementAsyncProcesses(\"Zotero.selectItems()\");","\t\t\t\t\t\t} else if(!callbackExecuted) {","\t\t\t\t\t\t\t// callback didn't get called from handler, so call it here","\t\t\t\t\t\t\tcallback(returnedItems);","\t\t\t\t\t\t}","\t\t\t\t\t\treturn false;","\t\t\t\t\t} else {","\t\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: No callback was provided for \"+","\t\t\t\t\t\t\t\"Zotero.selectItems(). When executed outside of Firefox, a selectItems() call \"+","\t\t\t\t\t\t\t\"will require this translator to be called multiple times.\", 1);","\t\t\t\t\t\t","\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t// The select handler is asynchronous, but this translator doesn't support","\t\t\t\t\t\t\t// asynchronous select. We return false to abort translation in this","\t\t\t\t\t\t\t// instance, and we will restart it later when the selectItems call is","\t\t\t\t\t\t\t// complete.","\t\t\t\t\t\t\ttranslate._aborted = true;","\t\t\t\t\t\t\treturn false;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\treturn returnedItems;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t} else { // no handler defined; assume they want all of them","\t\t\t\tif(callback) callback(items);","\t\t\t\treturn items;","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Overloads {@link Zotero.Translate.Sandbox.Base._itemDone} to ensure that no standalone","\t\t * items are saved, that an item type is specified, and to add a libraryCatalog and ","\t\t * shortTitle if relevant.","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox","\t\t */","\t\t \"_itemDone\":function(translate, item) {","\t\t \t// Only apply checks if there is no parent translator","\t\t \tif(!translate._parentTranslator) {","\t\t\t\tif(!item.itemType) {","\t\t\t\t\titem.itemType = \"webpage\";","\t\t\t\t\ttranslate._debug(\"WARNING: No item type specified\");","\t\t\t\t}","\t\t\t\t","\t\t\t\tif(item.type == \"attachment\" || item.type == \"note\") {","\t\t\t\t\tZotero.debug(\"Translate: Discarding standalone \"+item.type+\" in non-import translator\", 2);","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// store library catalog if this item was captured from a website, and","\t\t\t\t// libraryCatalog is truly undefined (not false or \"\")","\t\t\t\tif(item.repository !== undefined) {","\t\t\t\t\tZotero.debug(\"Translate: 'repository' field is now 'libraryCatalog'; please fix your code\", 2);","\t\t\t\t\titem.libraryCatalog = item.repository;","\t\t\t\t\tdelete item.repository;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// automatically set library catalog","\t\t\t\tif(item.libraryCatalog === undefined) {","\t\t\t\t\titem.libraryCatalog = translate.translator[0].label;","\t\t\t\t}","\t\t\t\t\t\t\t","\t\t\t\t// automatically set access date if URL is set","\t\t\t\tif(item.url && typeof item.accessDate == 'undefined') {","\t\t\t\t\titem.accessDate = \"CURRENT_TIMESTAMP\";","\t\t\t\t}","\t\t\t\t","\t\t\t\t//consider type-specific \"title\" alternatives","\t\t\t\tvar altTitle = Zotero.ItemFields.getName(Zotero.ItemFields.getFieldIDFromTypeAndBase(item.itemType, 'title'));","\t\t\t\tif(altTitle && item[altTitle]) item.title = item[altTitle];","\t\t\t\t","\t\t\t\tif(!item.title) {","\t\t\t\t\ttranslate.complete(false, new Error(\"No title specified for item\"));","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// create short title","\t\t\t\tif(item.shortTitle === undefined && Zotero.Utilities.fieldIsValidForType(\"shortTitle\", item.itemType)) {\t\t","\t\t\t\t\t// only set if changes have been made","\t\t\t\t\tvar setShortTitle = false;","\t\t\t\t\tvar title = item.title;","\t\t\t\t\t","\t\t\t\t\t// shorten to before first colon","\t\t\t\t\tvar index = title.indexOf(\":\");","\t\t\t\t\tif(index !== -1) {","\t\t\t\t\t\ttitle = title.substr(0, index);","\t\t\t\t\t\tsetShortTitle = true;","\t\t\t\t\t}","\t\t\t\t\t// shorten to after first question mark","\t\t\t\t\tindex = title.indexOf(\"?\");","\t\t\t\t\tif(index !== -1) {","\t\t\t\t\t\tindex++;","\t\t\t\t\t\tif(index != title.length) {","\t\t\t\t\t\t\ttitle = title.substr(0, index);","\t\t\t\t\t\t\tsetShortTitle = true;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(setShortTitle) item.shortTitle = title;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// refuse to save very long tags","\t\t\t\tif(item.tags) {","\t\t\t\t\tfor(var i=0; i<item.tags.length; i++) {","\t\t\t\t\t\tvar tag = item.tags[i];","\t\t\t\t\t\t\ttagString = typeof tag === \"string\" ? tag :","\t\t\t\t\t\t\t\ttypeof tag === \"object\" ? (tag.tag || tag.name) : null;","\t\t\t\t\t\tif(tagString && tagString.length > 255) {","\t\t\t\t\t\t\ttranslate._debug(\"WARNING: Skipping unsynchable tag \"+JSON.stringify(tagString));","\t\t\t\t\t\t\titem.tags.splice(i--, 1);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t","\t\t\t\tfor(var i=0; i<item.attachments.length; i++) {","\t\t\t\t\tvar attachment = item.attachments[i];","\t\t\t\t\t","\t\t\t\t\t// Web translators are not allowed to use attachment.path","\t\t\t\t\tif (attachment.path) {","\t\t\t\t\t\tif (!attachment.url) attachment.url = attachment.path;","\t\t\t\t\t\tdelete attachment.path;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(attachment.url) {","\t\t\t\t\t\t// Remap attachment (but not link) URLs","\t\t\t\t\t\tattachment.url = translate.resolveURL(attachment.url, attachment.snapshot === false);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\t// call super","\t\t\tZotero.Translate.Sandbox.Base._itemDone(translate, item);","\t\t},","\t\t","\t\t/**","\t\t * Tells Zotero to monitor changes to the DOM and re-trigger detectWeb","\t\t * Can only be set during the detectWeb call","\t\t * @param {DOMNode} target Document node to monitor for changes","\t\t * @param {MutationObserverInit} [config] specifies which DOM mutations should be reported","\t\t */","\t\t\"monitorDOMChanges\":function(translate, target, config) {","\t\t\tif(translate._currentState != \"detect\") {","\t\t\t\tZotero.debug(\"Translate: monitorDOMChanges can only be called during the 'detect' stage\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar window = translate.document.defaultView","\t\t\tvar mutationObserver = window && ( window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver );","\t\t\tif(!mutationObserver) {","\t\t\t\tZotero.debug(\"Translate: This browser does not support mutation observers.\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar translator = translate._potentialTranslators[0];","\t\t\tif(!translate._registeredDOMObservers[translator.translatorID])","\t\t\t\ttranslate._registeredDOMObservers[translator.translatorID] = [];","\t\t\tvar obs = translate._registeredDOMObservers[translator.translatorID];","","\t\t\t//do not re-register observer by the same translator for the same node","\t\t\tif(obs.indexOf(target) != -1) {","\t\t\t\tZotero.debug(\"Translate: Already monitoring this node\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tobs.push(target);","","\t\t\tvar observer = new mutationObserver(function(mutations, observer) {","\t\t\t\tobs.splice(obs.indexOf(target),1);","\t\t\t\tobserver.disconnect();","\t\t\t\t","\t\t\t\tZotero.debug(\"Translate: Page modified.\");","\t\t\t\t//we don't really care what got updated","\t\t\t\tvar doc = mutations[0].target.ownerDocument;","\t\t\t\ttranslate._runHandler(\"pageModified\", doc);","\t\t\t});","","\t\t\tobserver.observe(target, config || {childList: true, subtree: true});","\t\t\tZotero.debug(\"Translate: Mutation observer registered on <\" + target.nodeName + \"> node\");","\t\t}","\t},","","\t/**","\t * Import functions exposed to sandbox","\t * @namespace","\t */","\t\"Import\":{","\t\t/**","\t\t * Saves a collection to the DB","\t\t * Called as {@link Zotero.Collection#complete} from the sandbox","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxCollection} collection","\t\t */","\t\t\"_collectionDone\":function(translate, collection) {","\t\t\tif(translate._libraryID == false) {","\t\t\t\ttranslate.newCollections.push(collection);","\t\t\t\ttranslate._runHandler(\"collectionDone\", collection);","\t\t\t} else {","\t\t\t\tvar newCollection = translate._itemSaver.saveCollection(collection);","\t\t\t\ttranslate.newCollections.push(newCollection);","\t\t\t\ttranslate._runHandler(\"collectionDone\", newCollection);","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Sets the value of the progress indicator associated with export as a percentage","\t\t * @param {Zotero.Translate} translate","\t\t * @param {Number} value","\t\t */","\t\t\"setProgress\":function(translate, value) {","\t\t\tif(typeof value !== \"number\") {","\t\t\t\ttranslate._progress = null;","\t\t\t} else {","\t\t\t\ttranslate._progress = value;","\t\t\t}","\t\t}","\t},","","\t/**","\t * Export functions exposed to sandbox","\t * @namespace","\t */","\t\"Export\":{","\t\t/**","\t\t * Retrieves the next item to be exported","\t\t * @param {Zotero.Translate} translate","\t\t * @return {SandboxItem}","\t\t */","\t\t\"nextItem\":function(translate) {","\t\t\tvar item = translate._itemGetter.nextItem();","\t\t\t","\t\t\tif(translate._displayOptions.hasOwnProperty(\"exportTags\") && !translate._displayOptions[\"exportTags\"]) {","\t\t\t\titem.tags = [];","\t\t\t}","\t\t\t","\t\t\ttranslate._runHandler(\"itemDone\", item);","\t\t\t","\t\t\treturn item;","\t\t},","\t\t","\t\t/**","\t\t * Retrieves the next collection to be exported","\t\t * @param {Zotero.Translate} translate","\t\t * @return {SandboxCollection}","\t\t */","\t\t\"nextCollection\":function(translate) {","\t\t\tif(!translate._translatorInfo.configOptions || !translate._translatorInfo.configOptions.getCollections) {","\t\t\t\tthrow(new Error(\"getCollections configure option not set; cannot retrieve collection\"));","\t\t\t}","\t\t\t","\t\t\treturn translate._itemGetter.nextCollection();","\t\t},","\t\t","\t\t/**","\t\t * @borrows Zotero.Translate.Sandbox.Import.setProgress as this.setProgress","\t\t */","\t\t\"setProgress\":function(translate, value) {","\t\t\tZotero.Translate.Sandbox.Import.setProgress(translate, value);","\t\t}","\t},","\t","\t/**","\t * Search functions exposed to sandbox","\t * @namespace","\t */","\t\"Search\":{","\t\t/**","\t\t * @borrows Zotero.Translate.Sandbox.Web._itemDone as this._itemDone","\t\t */","\t\t\"_itemDone\":function(translate, item) {","\t\t\t// Always set library catalog, even if we have a parent translator","\t\t\tif(item.libraryCatalog === undefined) {","\t\t\t\titem.libraryCatalog = translate.translator[0].label;","\t\t\t}","\t\t\t","\t\t\tZotero.Translate.Sandbox.Web._itemDone(translate, item);","\t\t}","\t}","}","","/**"," * @class Base class for all translation types"," *"," * @property {String} type The type of translator. This is deprecated; use instanceof instead."," * @property {Zotero.Translator[]} translator The translator currently in use. Usually, only the"," *     first entry of the Zotero.Translator array is populated; subsequent entries represent"," *     translators to be used if the first fails."," * @property {String} path The path or URI string of the target"," * @property {String} newItems Items created when translate() was called"," * @property {String} newCollections Collections created when translate() was called"," * @property {Number} runningAsyncProcesses The number of async processes that are running. These"," *                                          need to terminate before Zotero.done() is called."," */","Zotero.Translate.Base = function() {}","Zotero.Translate.Base.prototype = {","\t/**","\t * Initializes a Zotero.Translate instance","\t */","\t\"init\":function() {","\t\tthis._handlers = [];","\t\tthis._currentState = null;","\t\tthis._translatorInfo = null;","\t\tthis.document = null;","\t\tthis.location = null;","\t},","\t","\t/**","\t * Sets the location to operate upon","\t *","\t * @param {String|nsIFile} location The URL to which the sandbox should be bound or path to local file","\t */","\t\"setLocation\":function(location) {","\t\tthis.location = location;","\t\tif(typeof this.location == \"object\") {\t// if a file","\t\t\tthis.path = location.path;","\t\t} else {\t\t\t\t\t\t\t\t// if a url","\t\t\tthis.path = location;","\t\t}","\t},","\t","\t/**","\t * Sets the translator to be used for import/export","\t *","\t * @param {Zotero.Translator|string} Translator object or ID","\t */","\t\"setTranslator\":function(translator) {","\t\tif(!translator) {","\t\t\tthrow new Error(\"No translator specified\");","\t\t}","\t\t","\t\tthis.translator = null;","\t\t","\t\tif(typeof(translator) == \"object\") {\t// passed an object and not an ID","\t\t\tif(translator.translatorID) {","\t\t\t\tthis.translator = [translator];","\t\t\t} else {","\t\t\t\tthrow(new Error(\"No translatorID specified\"));","\t\t\t}","\t\t} else {","\t\t\tthis.translator = [translator];","\t\t}","\t\t","\t\treturn !!this.translator;","\t},","\t","\t/**","\t * Registers a handler function to be called when translation is complete","\t *","\t * @param {String} type Type of handler to register. Legal values are:","\t * select","\t *   valid: web","\t *   called: when the user needs to select from a list of available items","\t *   passed: an associative array in the form id => text","\t *   returns: a numerically indexed array of ids, as extracted from the passed","\t *            string","\t * itemDone","\t *   valid: import, web, search","\t *   called: when an item has been processed; may be called asynchronously","\t *   passed: an item object (see Zotero.Item)","\t *   returns: N/A","\t * collectionDone","\t *   valid: import","\t *   called: when a collection has been processed, after all items have been","\t *           added; may be called asynchronously","\t *   passed: a collection object (see Zotero.Collection)","\t *   returns: N/A","\t * done","\t *   valid: all","\t *   called: when all processing is finished","\t *   passed: true if successful, false if an error occurred","\t *   returns: N/A","\t * debug","\t *   valid: all","\t *   called: when Zotero.debug() is called","\t *   passed: string debug message","\t *   returns: true if message should be logged to the console, false if not","\t * error","\t *   valid: all","\t *   called: when a fatal error occurs","\t *   passed: error object (or string)","\t *   returns: N/A","\t * translators","\t *   valid: all","\t *   called: when a translator search initiated with Zotero.Translate.getTranslators() is","\t *           complete","\t *   passed: an array of appropriate translators","\t *   returns: N/A","\t * pageModified","\t *   valid: web","\t *   called: when a web page has been modified","\t *   passed: the document object for the modified page","\t *   returns: N/A","\t * @param {Function} handler Callback function. All handlers will be passed the current","\t * translate instance as the first argument. The second argument is dependent on the handler.","\t */","\t\"setHandler\":function(type, handler) {","\t\tif(!this._handlers[type]) {","\t\t\tthis._handlers[type] = new Array();","\t\t}","\t\tthis._handlers[type].push(handler);","\t},","","\t/**","\t * Clears all handlers for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t */","\t\"clearHandlers\":function(type) {","\t\tthis._handlers[type] = new Array();","\t},","","\t/**","\t * Clears a single handler for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t * @param {Function} handler Callback function to remove","\t */","\t\"removeHandler\":function(type, handler) {","\t\tvar handlerIndex = this._handlers[type].indexOf(handler);","\t\tif(handlerIndex !== -1) this._handlers[type].splice(handlerIndex, 1);","\t},","\t","\t/**","\t * Indicates that a new async process is running","\t */","\t\"incrementAsyncProcesses\":function(f) {","\t\tthis._runningAsyncProcesses++;","\t\tif(this._parentTranslator) {","\t\t\tthis._parentTranslator.incrementAsyncProcesses(f+\" from child translator\");","\t\t} else {","\t\t\t//Zotero.debug(\"Translate: Incremented asynchronous processes to \"+this._runningAsyncProcesses+\" for \"+f, 4);","\t\t\t//Zotero.debug((new Error()).stack);","\t\t}","\t},","\t","\t/**","\t * Indicates that a new async process is finished","\t */","\t\"decrementAsyncProcesses\":function(f, by) {","\t\tthis._runningAsyncProcesses -= (by ? by : 1);","\t\tif(!this._parentTranslator) {","\t\t\t//Zotero.debug(\"Translate: Decremented asynchronous processes to \"+this._runningAsyncProcesses+\" for \"+f, 4);","\t\t\t//Zotero.debug((new Error()).stack);","\t\t}","\t\tif(this._runningAsyncProcesses === 0) {","\t\t\tthis.complete();","\t\t}","\t\tif(this._parentTranslator) this._parentTranslator.decrementAsyncProcesses(f+\" from child translator\", by);","\t},","","\t/**","\t * Clears all handlers for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t * @param {Any} argument Argument to be passed to handler","\t */","\t\"_runHandler\":function(type) {","\t\tvar returnValue = undefined;","\t\tif(this._handlers[type]) {","\t\t\t// compile list of arguments","\t\t\tif(this._parentTranslator) {","\t\t\t\t// if there is a parent translator, make sure we don't pass the Zotero.Translate","\t\t\t\t// object, since it could open a security hole","\t\t\t\tvar args = [null];","\t\t\t} else {","\t\t\t\tvar args = [this];","\t\t\t}","\t\t\tfor(var i=1; i<arguments.length; i++) {","\t\t\t\targs.push(arguments[i]);","\t\t\t}","\t\t\t","\t\t\tvar handlers = this._handlers[type].slice();","\t\t\tfor(var i=0, n=handlers.length; i<n; i++) {","\t\t\t\tZotero.debug(\"Translate: Running handler \"+i+\" for \"+type, 5);","\t\t\t\ttry {","\t\t\t\t\treturnValue = handlers[i].apply(null, args);","\t\t\t\t} catch(e) {","\t\t\t\t\tif(this._parentTranslator) {","\t\t\t\t\t\t// throw handler errors if they occur when a translator is","\t\t\t\t\t\t// called from another translator, so that the","\t\t\t\t\t\t// \"Could Not Translate\" dialog will appear if necessary","\t\t\t\t\t\tthrow(e);","\t\t\t\t\t} else {","\t\t\t\t\t\t// otherwise, fail silently, so as not to interfere with","\t\t\t\t\t\t// interface cleanup","\t\t\t\t\t\tZotero.debug(\"Translate: \"+e+' in handler '+i+' for '+type, 5);","\t\t\t\t\t\tZotero.logError(e);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn returnValue;","\t},","","\t/**","\t * Gets all applicable translators of a given type","\t *","\t * For import, you should call this after setLocation; otherwise, you'll just get a list of all","\t * import filters, not filters equipped to handle a specific file","\t *","\t * @param {Boolean} [getAllTranslators] Whether all applicable translators should be returned,","\t *     rather than just the first available.","\t * @param {Boolean} [checkSetTranslator] If true, the appropriate detect function is run on the","\t *     set document/text/etc. using the translator set by setTranslator.","\t *     getAllTranslators parameter is meaningless in this context.","\t * @return {Zotero.Translator[]} An array of {@link Zotero.Translator} objects","\t */","\t\"getTranslators\":function(getAllTranslators, checkSetTranslator) {","\t\t// do not allow simultaneous instances of getTranslators","\t\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\t\tthis._currentState = \"detect\";","\t\tthis._getAllTranslators = getAllTranslators;","","\t\tif(checkSetTranslator) {","\t\t\t// setTranslator must be called beforehand if checkSetTranslator is set","\t\t\tif( !this.translator || !this.translator[0] ) {","\t\t\t\tthrow new Error(\"getTranslators: translator must be set via setTranslator before calling\" +","\t\t\t\t\t\t\t\t\t\t\t\t\t\" getTranslators with the checkSetTranslator flag\");","\t\t\t}","\t\t\tvar translators = new Array();","\t\t\tvar t;","\t\t\tfor(var i=0, n=this.translator.length; i<n; i++) {","\t\t\t\tif(typeof(this.translator[i]) == 'string') {","\t\t\t\t\tt = Zotero.Translators.get(this.translator[i]);","\t\t\t\t\tif(!t) Zotero.debug(\"getTranslators: could not retrieve translator '\" + this.translator[i] + \"'\");","\t\t\t\t} else {","\t\t\t\t\tt = this.translator[i];","\t\t\t\t}","\t\t\t\t/**TODO: check that the translator is of appropriate type?*/","\t\t\t\tif(t) translators.push(t);","\t\t\t}","\t\t\tif(!translators.length) throw new Error(\"getTranslators: no valid translators were set.\");","\t\t\tthis._getTranslatorsTranslatorsReceived(translators);","\t\t} else {","\t\t\tthis._getTranslatorsGetPotentialTranslators();","\t\t}","","\t\t// if detection returns immediately, return found translators","\t\tif(!this._currentState) return this._foundTranslators;","\t},","\t","\t/**","\t * Get all potential translators","\t * @return {Zotero.Translator[]}","\t */","\t\"_getTranslatorsGetPotentialTranslators\":function() {","\t\tvar me = this;","\t\tZotero.Translators.getAllForType(this.type,","\t\t\tfunction(translators) { me._getTranslatorsTranslatorsReceived(translators) });","\t},","\t","\t/**","\t * Called on completion of {@link #_getTranslatorsGetPotentialTranslators} call","\t */","\t\"_getTranslatorsTranslatorsReceived\":function(allPotentialTranslators, properToProxyFunctions) {","\t\tthis._potentialTranslators = [];","\t\tthis._foundTranslators = [];","\t\t","\t\t// this gets passed out by Zotero.Translators.getWebTranslatorsForLocation() because it is","\t\t// specific for each translator, but we want to avoid making a copy of a translator whenever","\t\t// possible.","\t\tthis._properToProxyFunctions = properToProxyFunctions ? properToProxyFunctions : null;","\t\tthis._waitingForRPC = false;","\t\t","\t\tfor(var i=0, n=allPotentialTranslators.length; i<n; i++) {","\t\t\tvar translator = allPotentialTranslators[i];","\t\t\tif(translator.runMode === Zotero.Translator.RUN_MODE_IN_BROWSER) {","\t\t\t\tthis._potentialTranslators.push(translator);","\t\t\t} else if(this instanceof Zotero.Translate.Web && Zotero.Connector) {","\t\t\t\tthis._waitingForRPC = true;","\t\t\t}","\t\t}","\t\t","\t\tif(this._waitingForRPC) {","\t\t\tvar me = this;","\t\t\tZotero.Connector.callMethod(\"detect\", {\"uri\":this.location.toString(),","\t\t\t\t\"cookie\":this.document.cookie,","\t\t\t\t\"html\":this.document.documentElement.innerHTML},","\t\t\t\tfunction(returnValue) { me._getTranslatorsRPCComplete(returnValue) });","\t\t}","\t\t","\t\tthis._detect();","\t},","\t","\t/**","\t * Called on completion of detect RPC for","\t * {@link Zotero.Translate.Base#_getTranslatorsTranslatorsReceived}","\t */","\t \"_getTranslatorsRPCComplete\":function(rpcTranslators) {","\t\tthis._waitingForRPC = false;","\t\t","\t\t// if there are translators, add them to the list of found translators","\t\tif(rpcTranslators) {","\t\t\tfor(var i=0, n=rpcTranslators.length; i<n; i++) {","\t\t\t\trpcTranslators[i].runMode = Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE;","\t\t\t}","\t\t\tthis._foundTranslators = this._foundTranslators.concat(rpcTranslators);","\t\t}","\t\t","\t\t// call _detectTranslatorsCollected to return detected translators","\t\tif(this._currentState === null) {","\t\t\tthis._detectTranslatorsCollected();","\t\t}","\t },","","\t/**","\t * Begins the actual translation. At present, this returns immediately for import/export","\t * translators, but new code should use {@link Zotero.Translate.Base#setHandler} to register a ","\t * \"done\" handler to determine when execution of web/search translators is complete.","\t *","\t * @param \t{NULL|Integer|FALSE}\t[libraryID=null]\t\tLibrary in which to save items,","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tor NULL for default library;","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif FALSE, don't save items","\t * @param \t{Boolean}\t\t\t\t[saveAttachments=true]\tExclude attachments (e.g., snapshots) on import","\t */","\t\"translate\":function(libraryID, saveAttachments) {\t\t// initialize properties specific to each translation","\t\tif(!this.translator || !this.translator.length) {","\t\t\tvar args = arguments;","\t\t\tZotero.debug(\"Translate: translate called without specifying a translator. Running detection first.\");","\t\t\tthis.setHandler('translators', function(me, translators) {","\t\t\t\tif(!translators.length) {","\t\t\t\t\tme.complete(false, \"Could not find an appropriate translator\");","\t\t\t\t} else {","\t\t\t\t\tme.setTranslator(translators);","\t\t\t\t\tZotero.Translate.Base.prototype.translate.apply(me, args);","\t\t\t\t}","\t\t\t});","\t\t\tthis.getTranslators();","\t\t\treturn;","\t\t}","\t\t","\t\tthis._currentState = \"translate\";","\t\t","\t\tthis._libraryID = libraryID;","\t\tthis._saveAttachments = saveAttachments === undefined || saveAttachments;","\t\tthis._savingAttachments = [];","\t\tthis._savingItems = 0;","\t\tthis._waitingForSave = false;","\t\t","\t\tvar me = this;","\t\tif(typeof this.translator[0] === \"object\") {","\t\t\t// already have a translator object, so use it","\t\t\tthis._loadTranslator(this.translator[0], function() { me._translateTranslatorLoaded() });","\t\t} else {","\t\t\t// need to get translator first","\t\t\tZotero.Translators.get(this.translator[0],","\t\t\t\t\tfunction(translator) {","\t\t\t\t\t\tme.translator[0] = translator;","\t\t\t\t\t\tme._loadTranslator(translator, function() { me._translateTranslatorLoaded() });","\t\t\t\t\t});","\t\t}","\t},","\t","\t/**","\t * Called when translator has been retrieved and loaded","\t */","\t\"_translateTranslatorLoaded\":function() {","\t\tif(!this.translator[0].code) {","\t\t\tthis.complete(false,","\t\t\t\tnew Error(\"Translator \"+this.translator[0].label+\" is unsupported within this environment\"));","\t\t\treturn;","\t\t}","\t\t","\t\t// set display options to default if they don't exist","\t\tif(!this._displayOptions) this._displayOptions = this._translatorInfo.displayOptions || {};","\t\t","\t\t// prepare translation","\t\tthis._prepareTranslation();","\t\t","\t\tZotero.debug(\"Translate: Beginning translation with \"+this.translator[0].label);","\t\t","\t\tthis.incrementAsyncProcesses(\"Zotero.Translate#translate()\");","\t\t","\t\t// translate","\t\ttry {","\t\t\tFunction.prototype.apply.call(this._sandboxManager.sandbox[\"do\"+this._entryFunctionSuffix], null, this._getParameters());","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn false;","\t\t}","\t\t","\t\tthis.decrementAsyncProcesses(\"Zotero.Translate#translate()\");","\t},","\t","\t/**","\t * Return the progress of the import operation, or null if progress cannot be determined","\t */","\t\"getProgress\":function() { return null },","","\t/**","\t * Translate a URL to a form that goes through the appropriate proxy, or","\t * convert a relative URL to an absolute one","\t *","\t * @param {String} url","\t * @param {Boolean} dontUseProxy If true, don't convert URLs to variants","\t *     that use the proxy","\t * @type String","\t * @private","\t */","\t\"resolveURL\":function(url, dontUseProxy) {","\t\tconst hostPortRe = /^((?:http|https|ftp):)\\/\\/([^\\/]+)/i;","\t\t// resolve local URL","\t\tvar resolved = \"\";","\t\t","\t\t// convert proxy to proper if applicable","\t\tif(hostPortRe.test(url)) {","\t\t\tif(this.translator && this.translator[0]","\t\t\t\t\t&& this.translator[0].properToProxy && !dontUseProxy) {","\t\t\t\tresolved = this.translator[0].properToProxy(url);","\t\t\t} else {","\t\t\t\tresolved = url;","\t\t\t}","\t\t} else if(Zotero.isFx) {","\t\t\tresolved = Components.classes[\"@mozilla.org/network/io-service;1\"].","\t\t\t\tgetService(Components.interfaces.nsIIOService).","\t\t\t\tnewURI(this.location, \"\", null).resolve(url);","\t\t} else if(Zotero.isNode) {","\t\t\tresolved = require('url').resolve(this.location, url);","\t\t} else {","\t\t\tvar a = document.createElement('a');","\t        a.href = url;","\t        resolved = a.href;","\t\t}","\t\t","\t\t/*var m = hostPortRe.exec(resolved);","\t\tif(!m) {","\t\t\tthrow new Error(\"Invalid URL supplied for HTTP request: \"+url);","\t\t} else if(this._translate.document && this._translate.document.location) {","\t\t\tvar loc = this._translate.document.location;","\t\t\tif(this._translate._currentState !== \"translate\" && loc","\t\t\t\t\t&& (m[1].toLowerCase() !== loc.protocol.toLowerCase()","\t\t\t\t\t|| m[2].toLowerCase() !== loc.host.toLowerCase())) {","\t\t\t\tthrow new Error(\"Attempt to access \"+m[1]+\"//\"+m[2]+\" from \"+loc.protocol+\"//\"+loc.host","\t\t\t\t\t+\" blocked: Cross-site requests are only allowed during translation\");","\t\t\t}","\t\t}*/","\t\t","\t\treturn resolved;","\t},","\t","\t/**","\t * Executed on translator completion, either automatically from a synchronous scraper or as","\t * done() from an asynchronous scraper. Finishes things up and calls callback function(s).","\t * @param {Boolean|String} returnValue An item type or a boolean true or false","\t * @param {String|Exception} [error] An error that occurred during translation.","\t * @returm {String|NULL} The exception serialized to a string, or null if translation","\t *     completed successfully.","\t */","\t\"complete\":function(returnValue, error) {","\t\t// allow translation to be aborted for re-running after selecting items","\t\tif(this._aborted) return;","\t\t","\t\t// Make sure this isn't called twice","\t\tif(this._currentState === null) {","\t\t\tif(!returnValue) {","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.done() called after translator completion with error\");","\t\t\t\tZotero.debug(error);","\t\t\t} else {","\t\t\t\tvar e = new Error();","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.done() called after translation completion. This should never happen. Please examine the stack below.\");","\t\t\t\tZotero.debug(e.stack);","\t\t\t}","\t\t\treturn;","\t\t}","\t\t","\t\t// reset async processes and propagate them to parent","\t\tif(this._parentTranslator && this._runningAsyncProcesses) {","\t\t\tthis._parentTranslator.decrementAsyncProcesses(\"Zotero.Translate#complete\", this._runningAsyncProcesses);","\t\t}","\t\tthis._runningAsyncProcesses = 0;","\t\t","\t\tif(!returnValue && this._returnValue) returnValue = this._returnValue;","\t\t","\t\tvar errorString = null;","\t\tif(!returnValue && error) errorString = this._generateErrorString(error);","\t\t","\t\tif(this._currentState === \"detect\") {","\t\t\tif(this._potentialTranslators.length) {","\t\t\t\tvar lastTranslator = this._potentialTranslators.shift();","\t\t\t\tvar lastProperToProxyFunction = this._properToProxyFunctions ? this._properToProxyFunctions.shift() : null;","\t\t\t\t","\t\t\t\tif(returnValue) {","\t\t\t\t\tvar dupeTranslator = {\"properToProxy\":lastProperToProxyFunction};","\t\t\t\t\t","\t\t\t\t\tfor(var i in lastTranslator) dupeTranslator[i] = lastTranslator[i];","\t\t\t\t\tif(Zotero.isBookmarklet && returnValue === \"server\") {","\t\t\t\t\t\t// In the bookmarklet, the return value from detectWeb can be \"server\" to","\t\t\t\t\t\t// indicate the translator should be run on the Zotero server","\t\t\t\t\t\tdupeTranslator.runMode = Zotero.Translator.RUN_MODE_ZOTERO_SERVER;","\t\t\t\t\t} else {","\t\t\t\t\t\t// Usually the return value from detectWeb will be either an item type or","\t\t\t\t\t\t// the string \"multiple\"","\t\t\t\t\t\tdupeTranslator.itemType = returnValue;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tthis._foundTranslators.push(dupeTranslator);","\t\t\t\t} else if(error) {","\t\t\t\t\tthis._debug(\"Detect using \"+lastTranslator.label+\" failed: \\n\"+errorString, 2);","\t\t\t\t}","\t\t\t}","\t\t\t\t","\t\t\tif(this._potentialTranslators.length && (this._getAllTranslators || !returnValue)) {","\t\t\t\t// more translators to try; proceed to next translator","\t\t\t\tthis._detect();","\t\t\t} else {","\t\t\t\tthis._currentState = null;","\t\t\t\tif(!this._waitingForRPC) this._detectTranslatorsCollected();","\t\t\t}","\t\t} else {","\t\t\t// unset return value is equivalent to true","\t\t\tif(returnValue === undefined) returnValue = true;","\t\t\t","\t\t\tif(returnValue) {","\t\t\t\tif(this.saveQueue.length) {","\t\t\t\t\tthis._waitingForSave = true;","\t\t\t\t\tthis._saveItems(this.saveQueue);","\t\t\t\t\tthis.saveQueue = [];","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\tthis._debug(\"Translation successful\");","\t\t\t} else {","\t\t\t\tif(error) {","\t\t\t\t\t// report error to console","\t\t\t\t\tZotero.logError(error);","\t\t\t\t\t","\t\t\t\t\t// report error to debug log","\t\t\t\t\tthis._debug(\"Translation using \"+(this.translator && this.translator[0] && this.translator[0].label ? this.translator[0].label : \"no translator\")+\" failed: \\n\"+errorString, 2);","\t\t\t\t}","\t\t\t\t","\t\t\t\tthis._runHandler(\"error\", error);","\t\t\t}","\t\t\t","\t\t\tthis._currentState = null;","\t\t\t","\t\t\t// call handlers","\t\t\tthis._runHandler(\"itemsDone\", returnValue);","\t\t\tif(returnValue) {","\t\t\t\tthis._checkIfDone();","\t\t\t} else {","\t\t\t\tthis._runHandler(\"done\", returnValue);","\t\t\t}","\t\t}","\t\t","\t\treturn errorString;","\t},","\t","\t/**","\t * Saves items to the database, taking care to defer attachmentProgress notifications","\t * until after save","\t */","\t\"_saveItems\":function(items) {","\t\tvar me = this,","\t\t\titemDoneEventsDispatched = false,","\t\t\tdeferredProgress = [],","\t\t\tattachmentsWithProgress = [];","\t\t","\t\tthis._savingItems++;","\t\tthis._itemSaver.saveItems(items.slice(), function(returnValue, newItems) {\t","\t\t\tif(returnValue) {","\t\t\t\t// Remove attachments not being saved from item.attachments","\t\t\t\tfor(var i=0; i<items.length; i++) {","\t\t\t\t\tvar item = items[i];","\t\t\t\t\tfor(var j=0; j<item.attachments.length; j++) {","\t\t\t\t\t\tif(attachmentsWithProgress.indexOf(item.attachments[j]) === -1) {","\t\t\t\t\t\t\titem.attachments.splice(j--, 1);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t","\t\t\t\t// Trigger itemDone events","\t\t\t\tfor(var i=0, nItems = items.length; i<nItems; i++) {","\t\t\t\t\tme._runHandler(\"itemDone\", newItems[i], items[i]);","\t\t\t\t}","\t\t\t\t","\t\t\t\t// Specify that itemDone event was dispatched, so that we don't defer","\t\t\t\t// attachmentProgress notifications anymore","\t\t\t\titemDoneEventsDispatched = true;","\t\t\t\t","\t\t\t\t// Run deferred attachmentProgress notifications","\t\t\t\tfor(var i=0; i<deferredProgress.length; i++) {","\t\t\t\t\tme._runHandler(\"attachmentProgress\", deferredProgress[i][0],","\t\t\t\t\t\tdeferredProgress[i][1], deferredProgress[i][2]);","\t\t\t\t}","\t\t\t\t","\t\t\t\tme.newItems = me.newItems.concat(newItems);","\t\t\t\tme._savingItems--;","\t\t\t\tme._checkIfDone();","\t\t\t} else {","\t\t\t\tZotero.logError(newItems);","\t\t\t\tme.complete(returnValue, newItems);","\t\t\t}","\t\t},","\t\tfunction(attachment, progress, error) {","\t\t\tvar attachmentIndex = me._savingAttachments.indexOf(attachment);","\t\t\tif(progress === false || progress === 100) {","\t\t\t\tif(attachmentIndex !== -1) {","\t\t\t\t\tme._savingAttachments.splice(attachmentIndex, 1);","\t\t\t\t}","\t\t\t} else if(attachmentIndex === -1) {","\t\t\t\tme._savingAttachments.push(attachment);","\t\t\t}","\t\t\t","\t\t\tif(itemDoneEventsDispatched) {","\t\t\t\t// itemDone event has already fired, so we can fire attachmentProgress","\t\t\t\t// notifications","\t\t\t\tme._runHandler(\"attachmentProgress\", attachment, progress, error);","\t\t\t\tme._checkIfDone();","\t\t\t} else {","\t\t\t\t// Defer until after we fire the itemDone event","\t\t\t\tdeferredProgress.push([attachment, progress, error]);","\t\t\t\tattachmentsWithProgress.push(attachment);","\t\t\t}","\t\t});","\t},","\t","\t/**","\t * Checks if saving done, and if so, fires done event","\t */","\t\"_checkIfDone\":function() {","\t\tif(!this._savingItems && !this._savingAttachments.length && (!this._currentState || this._waitingForSave)) {","\t\t\tthis._runHandler(\"done\", true);","\t\t}","\t},","\t","\t/**","\t * Begins running detect code for a translator, first loading it","\t */","\t\"_detect\":function() {","\t\t// there won't be any translators if we need an RPC call","\t\tif(!this._potentialTranslators.length) {","\t\t\tthis.complete(true);","\t\t\treturn;","\t\t}","\t\t","\t\tvar me = this;","\t\tthis._loadTranslator(this._potentialTranslators[0],","\t\t\tfunction() { me._detectTranslatorLoaded() });","\t},","\t","\t/**","\t * Runs detect code for a translator","\t */","\t\"_detectTranslatorLoaded\":function() {","\t\tthis._prepareDetection();","\t\t","\t\tthis.incrementAsyncProcesses(\"Zotero.Translate#getTranslators\");","\t\t","\t\ttry {","\t\t\tvar returnValue = Function.prototype.apply.call(this._sandboxManager.sandbox[\"detect\"+this._entryFunctionSuffix], null, this._getParameters());","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn;","\t\t}","\t\t","\t\tif(returnValue !== undefined) this._returnValue = returnValue;","\t\tthis.decrementAsyncProcesses(\"Zotero.Translate#getTranslators\");","\t},","\t","\t/**","\t * Called when all translators have been collected for detection","\t */","\t\"_detectTranslatorsCollected\":function() {","\t\tZotero.debug(\"Translate: All translator detect calls and RPC calls complete\");","\t\tthis._foundTranslators.sort(function(a, b) { return a.priority-b.priority });","\t\tthis._runHandler(\"translators\", this._foundTranslators);","\t},","\t","\t/**","\t * Loads the translator into its sandbox","\t * @param {Zotero.Translator} translator","\t * @return {Boolean} Whether the translator could be successfully loaded","\t */","\t\"_loadTranslator\":function(translator, callback) {","\t\tvar sandboxLocation = this._getSandboxLocation();","\t\tif(!this._sandboxLocation || sandboxLocation !== this._sandboxLocation) {","\t\t\tthis._sandboxLocation = sandboxLocation;","\t\t\tthis._generateSandbox();","\t\t}","\t\t","\t\tthis._currentTranslator = translator;","\t\tthis._runningAsyncProcesses = 0;","\t\tthis._returnValue = undefined;","\t\tthis._aborted = false;","\t\tthis.saveQueue = [];","\t\t","\t\tZotero.debug(\"Translate: Parsing code for \"+translator.label, 4);","\t\t","\t\ttry {","\t\t\tthis._sandboxManager.eval(\"var exports = {}, ZOTERO_TRANSLATOR_INFO = \"+translator.code,","\t\t\t\t[\"detect\"+this._entryFunctionSuffix, \"do\"+this._entryFunctionSuffix, \"exports\",","\t\t\t\t\t\"ZOTERO_TRANSLATOR_INFO\"],","\t\t\t\t(translator.file ? translator.file.path : translator.label));","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn;","\t\t}","\t\tthis._translatorInfo = this._sandboxManager.sandbox.ZOTERO_TRANSLATOR_INFO;","\t\t","\t\tif(callback) callback();","\t},","\t","\t/**","\t * Generates a sandbox for scraping/scraper detection","\t */","\t\"_generateSandbox\":function() {","\t\tZotero.debug(\"Translate: Binding sandbox to \"+(typeof this._sandboxLocation == \"object\" ? this._sandboxLocation.document.location : this._sandboxLocation), 4);","\t\tif (this._parentTranslator && this._parentTranslator._sandboxManager.newChild) {","\t\t\tthis._sandboxManager = this._parentTranslator._sandboxManager.newChild();","\t\t} else {","\t\t\tthis._sandboxManager = new Zotero.Translate.SandboxManager(this._sandboxLocation);","\t\t}","\t\tconst createArrays = \"['creators', 'notes', 'tags', 'seeAlso', 'attachments']\";","\t\tvar src = \"var Zotero = {};\"+","\t\t\"Zotero.Item = function (itemType) {\"+","\t\t\t\t\"const createArrays = \"+createArrays+\";\"+","\t\t\t\t\"this.itemType = itemType;\"+","\t\t\t\t\"for(var i=0, n=createArrays.length; i<n; i++) {\"+","\t\t\t\t\t\"this[createArrays[i]] = [];\"+","\t\t\t\t\"}\"+","\t\t\"};\";","\t\t","\t\tif(this instanceof Zotero.Translate.Export || this instanceof Zotero.Translate.Import) {","\t\t\tsrc += \"Zotero.Collection = function () {};\"+","\t\t\t\"Zotero.Collection.prototype.complete = function() { Zotero._collectionDone(this); };\";","\t\t}","\t\t","\t\tif(Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t// workaround for inadvertant attempts to pass E4X back from sandbox","\t\t\tsrc += \"Zotero.Item.prototype.complete = function() { \"+","\t\t\t\t\t\"for(var key in this) {\"+","\t\t\t\t\t\"if(\"+createArrays+\".indexOf(key) !== -1) {\"+","\t\t\t\t\t\t\"for each(var item in this[key]) {\"+","\t\t\t\t\t\t\t\"for(var key2 in item) {\"+","\t\t\t\t\t\t\t\t\"if(typeof item[key2] === 'xml') {\"+","\t\t\t\t\t\t\t\t\t\"item[key2] = item[key2].toString();\"+","\t\t\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\"} else if(typeof this[key] === 'xml') {\"+","\t\t\t\t\t\t\"this[key] = this[key].toString();\"+","\t\t\t\t\t\"}\"+","\t\t\t\t\"}\";","\t\t} else {","\t\t\tsrc += \"Zotero.Item.prototype.complete = function() { \";","\t\t}","\t\t","\t\tsrc += \"Zotero._itemDone(this);\"+","\t\t\"}\";","","\t\tthis._sandboxManager.eval(src);","\t\tthis._sandboxManager.importObject(this.Sandbox, this);","\t\tthis._sandboxManager.importObject({\"Utilities\":new Zotero.Utilities.Translate(this)});","","\t\tthis._sandboxZotero = this._sandboxManager.sandbox.Zotero;","","\t\tif(Zotero.isFx) {","\t\t\tif(this._sandboxZotero.wrappedJSObject) this._sandboxZotero = this._sandboxZotero.wrappedJSObject;","\t\t}","\t\tthis._sandboxZotero.Utilities.HTTP = this._sandboxZotero.Utilities;","\t\t","\t\tthis._sandboxZotero.isBookmarklet = Zotero.isBookmarklet || false;","\t\tthis._sandboxZotero.isConnector = Zotero.isConnector || false;","\t\tthis._sandboxZotero.isServer = Zotero.isServer || false;","\t\tthis._sandboxZotero.parentTranslator = this._parentTranslator","\t\t\t&& this._parentTranslator._currentTranslator ? ","\t\t\tthis._parentTranslator._currentTranslator.translatorID : null;","\t\t","\t\t// create shortcuts","\t\tthis._sandboxManager.sandbox.Z = this._sandboxZotero;","\t\tthis._sandboxManager.sandbox.ZU = this._sandboxZotero.Utilities;","\t\tthis._transferItem = this._sandboxZotero._transferItem;","\t},","\t","\t/**","\t * Logs a debugging message","\t * @param {String} string Debug string to log","\t * @param {Integer} level Log level (1-5, higher numbers are higher priority)","\t */","\t\"_debug\":function(string, level) {","\t\tif(level !== undefined && typeof level !== \"number\") {","\t\t\tZotero.debug(\"debug: level must be an integer\");","\t\t\treturn;","\t\t}","\t\t","\t\t// if handler does not return anything explicitly false, show debug","\t\t// message in console","\t\tif(this._runHandler(\"debug\", string) !== false) {","\t\t\tif(typeof string == \"string\") string = \"Translate: \"+string;","\t\t\tZotero.debug(string, level);","\t\t}","\t},","\t/**","\t * Generates a string from an exception","\t * @param {String|Exception} error","\t */","\t\"_generateErrorString\":function(error) {","\t\tvar errorString = \"\";","\t\tif(typeof(error) == \"string\") {","\t\t\terrorString = \"\\nthrown exception => \"+error;","\t\t} else {","\t\t\tvar haveStack = false;","\t\t\tfor(var i in error) {","\t\t\t\tif(typeof(error[i]) != \"object\") {","\t\t\t\t\tif(i === \"stack\") haveStack = true;","\t\t\t\t\terrorString += \"\\n\"+i+' => '+error[i];","\t\t\t\t}","\t\t\t}","\t\t\terrorString += \"\\nstring => \"+error.toString();","\t\t\tif(!haveStack && error.stack) {","\t\t\t\t// In case the stack is not enumerable","\t\t\t\terrorString += \"\\nstack => \"+error.stack.toString();","\t\t\t}","\t\t}","\t\t","\t\terrorString += \"\\nurl => \"+this.path","\t\t\t+ \"\\ndownloadAssociatedFiles => \"+Zotero.Prefs.get(\"downloadAssociatedFiles\")","\t\t\t+ \"\\nautomaticSnapshots => \"+Zotero.Prefs.get(\"automaticSnapshots\");","\t\treturn errorString.substr(1);","\t},","\t","\t/**","\t * Determines the location where the sandbox should be bound","\t * @return {String|document} The location to which to bind the sandbox","\t */","\t\"_getSandboxLocation\":function() {","\t\treturn (this._parentTranslator ? this._parentTranslator._sandboxLocation : \"http://www.example.com/\");","\t},","\t","\t/**","\t * Gets parameters to be passed to detect* and do* functions","\t * @return {Array} A list of parameters","\t */","\t\"_getParameters\":function() { return []; },","\t","\t/**","\t * No-op for preparing detection","\t */","\t\"_prepareDetection\":function() {},","\t","\t/**","\t * No-op for preparing translation","\t */","\t\"_prepareTranslation\":function() {}","}","","/**"," * @class Web translation"," *"," * @property {Document} document The document object to be used for web scraping (set with setDocument)"," * @property {Zotero.CookieSandbox} cookieSandbox A CookieSandbox to manage cookies for"," *     this Translate instance."," */","Zotero.Translate.Web = function() {","\tthis._registeredDOMObservers = {}","\tthis.init();","}","Zotero.Translate.Web.prototype = new Zotero.Translate.Base();","Zotero.Translate.Web.prototype.type = \"web\";","Zotero.Translate.Web.prototype._entryFunctionSuffix = \"Web\";","Zotero.Translate.Web.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Web);","","/**"," * Sets the browser to be used for web translation"," * @param {Document} doc An HTML document"," */","Zotero.Translate.Web.prototype.setDocument = function(doc) {","\tthis.document = doc;","\tthis.setLocation(doc.location.href);","}","","/**"," * Sets a Zotero.CookieSandbox to handle cookie management for XHRs initiated from this"," * translate instance"," *"," * @param {Zotero.CookieSandbox} cookieSandbox"," */","Zotero.Translate.Web.prototype.setCookieSandbox = function(cookieSandbox) {","\tthis.cookieSandbox = cookieSandbox;","}","","/**"," * Sets the location to operate upon"," *"," * @param {String} location The URL of the page to translate"," */","Zotero.Translate.Web.prototype.setLocation = function(location) {","\tthis.location = location;","\tthis.path = this.location;","}","","/**"," * Get potential web translators"," */","Zotero.Translate.Web.prototype._getTranslatorsGetPotentialTranslators = function() {","\tvar me = this;","\tZotero.Translators.getWebTranslatorsForLocation(this.location,","\t\t\tfunction(data) {","\t\t\t\t// data[0] = list of translators","\t\t\t\t// data[1] = list of functions to convert proper URIs to proxied URIs","\t\t\t\tme._getTranslatorsTranslatorsReceived(data[0], data[1]);","\t\t\t});","}","","/**"," * Bind sandbox to document being translated"," */","Zotero.Translate.Web.prototype._getSandboxLocation = function() {","\tif(this._parentTranslator) {","\t\treturn this._parentTranslator._sandboxLocation;","\t} else if(this.document.defaultView","\t\t\t&& (this.document.defaultView.toString().indexOf(\"Window\") !== -1","\t\t\t\t|| this.document.defaultView.toString().indexOf(\"XrayWrapper\") !== -1)) {","\t\treturn this.document.defaultView;","\t} else {","\t\treturn this.document.location.toString();","\t}","}","","/**"," * Pass document and location to detect* and do* functions"," */","Zotero.Translate.Web.prototype._getParameters = function() {","\tif (Zotero.Translate.DOMWrapper &&","\t\tZotero.Translate.DOMWrapper.isWrapped(this.document) &&","\t\tZotero.platformMajorVersion >= 35) {","\t\treturn [this._sandboxManager.wrap(Zotero.Translate.DOMWrapper.unwrap(this.document), null,","\t\t\t                              this.document.__wrapperOverrides), this.location];","\t} else {","\t\treturn [this.document, this.location];","\t}","};","","/**"," * Prepare translation"," */","Zotero.Translate.Web.prototype._prepareTranslation = function() {","\tthis._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,","\t\tZotero.Translate.ItemSaver[(this._saveAttachments ? \"ATTACHMENT_MODE_DOWNLOAD\" : \"ATTACHMENT_MODE_IGNORE\")], 1,","\t\tthis.document, this._cookieSandbox, this.location);","\tthis.newItems = [];","}","","/**"," * Overload translate to set selectedItems"," */","Zotero.Translate.Web.prototype.translate = function(libraryID, saveAttachments, selectedItems) {","\tthis._selectedItems = selectedItems;","\tZotero.Translate.Base.prototype.translate.apply(this, [libraryID, saveAttachments]);","}","","/**"," * Overload _translateTranslatorLoaded to send an RPC call if necessary"," */","Zotero.Translate.Web.prototype._translateTranslatorLoaded = function() {","\tvar runMode = this.translator[0].runMode;","\tif(runMode === Zotero.Translator.RUN_MODE_IN_BROWSER || this._parentTranslator) {","\t\tZotero.Translate.Base.prototype._translateTranslatorLoaded.apply(this);","\t} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE ||","\t\t\t(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER && Zotero.Connector.isOnline)) {","\t\tvar me = this;","\t\tZotero.Connector.callMethod(\"savePage\", {","\t\t\t\t\"uri\":this.location.toString(),","\t\t\t\t\"translatorID\":(typeof this.translator[0] === \"object\"","\t\t\t\t                ? this.translator[0].translatorID : this.translator[0]),","\t\t\t\t\"cookie\":this.document.cookie,","\t\t\t\t\"html\":this.document.documentElement.innerHTML","\t\t\t}, function(obj) { me._translateRPCComplete(obj) });","\t} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER) {","\t\tvar me = this;","\t\tZotero.API.createItem({\"url\":this.document.location.href.toString()},","\t\t\tfunction(statusCode, response) {","\t\t\t\tme._translateServerComplete(statusCode, response);","\t\t\t});","\t}","}","\t","/**"," * Called when an call to Zotero Standalone for translation completes"," */","Zotero.Translate.Web.prototype._translateRPCComplete = function(obj, failureCode) {","\tif(!obj) this.complete(false, failureCode);","\t","\tif(obj.selectItems) {","\t\t// if we have to select items, call the selectItems handler and do it","\t\tvar me = this;","\t\tthis._runHandler(\"select\", obj.selectItems,","\t\t\tfunction(selectedItems) {","\t\t\t\tZotero.Connector.callMethod(\"selectItems\",","\t\t\t\t\t{\"instanceID\":obj.instanceID, \"selectedItems\":selectedItems},","\t\t\t\t\tfunction(obj) { me._translateRPCComplete(obj) })","\t\t\t}","\t\t);","\t} else {","\t\t// if we don't have to select items, continue","\t\tfor(var i=0, n=obj.items.length; i<n; i++) {","\t\t\tthis._runHandler(\"itemDone\", null, obj.items[i]);","\t\t}","\t\tthis.newItems = obj.items;","\t\tthis.complete(true);","\t}","}","\t","/**"," * Called when an call to the Zotero Translator Server for translation completes"," */","Zotero.Translate.Web.prototype._translateServerComplete = function(statusCode, response) {","\tif(statusCode === 300) {","\t\t// Multiple Choices","\t\ttry {","\t\t\tresponse = JSON.parse(response);","\t\t} catch(e) {","\t\t\tZotero.logError(e);","\t\t\tthis.complete(false, \"Invalid JSON response received from server\");","\t\t\treturn;","\t\t}","\t\tvar me = this;","\t\tthis._runHandler(\"select\", response,","\t\t\tfunction(selectedItems) {","\t\t\t\tZotero.API.createItem({","\t\t\t\t\t\t\"url\":me.document.location.href.toString(),","\t\t\t\t\t\t\"items\":selectedItems","\t\t\t\t\t},","\t\t\t\t\tfunction(statusCode, response) {","\t\t\t\t\t\t\tme._translateServerComplete(statusCode, response);","\t\t\t\t\t});","\t\t\t}","\t\t);","\t} else if(statusCode === 201) {","\t\t// Created","\t\ttry {","\t\t\tresponse = (new DOMParser()).parseFromString(response, \"application/xml\");","\t\t} catch(e) {","\t\t\tZotero.logError(e);","\t\t\tthis.complete(false, \"Invalid XML response received from server\");","\t\t\treturn;","\t\t}","\t\t","\t\t// Extract items from ATOM/JSON response","\t\tvar items = [], contents;","\t\tif(\"getElementsByTagNameNS\" in response) {","\t\t\tcontents = response.getElementsByTagNameNS(\"http://www.w3.org/2005/Atom\", \"content\");","\t\t} else { // IE...","\t\t\tcontents = response.getElementsByTagName(\"content\");","\t\t}","\t\tfor(var i=0, n=contents.length; i<n; i++) {","\t\t\tvar content = contents[i];","\t\t\tif(\"getAttributeNS\" in content) {","\t\t\t\tif(content.getAttributeNS(\"http://zotero.org/ns/api\", \"type\") != \"json\") continue;","\t\t\t} else if(content.getAttribute(\"zapi:type\") != \"json\") { // IE...","\t\t\t\tcontinue;","\t\t\t}","\t\t\t","\t\t\ttry {","\t\t\t\tvar item = JSON.parse(\"textContent\" in content ?","\t\t\t\t\tcontent.textContent : content.text);","\t\t\t} catch(e) {","\t\t\t\tZotero.logError(e);","\t\t\t\tthis.complete(false, \"Invalid JSON response received from server\");","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\tif(!(\"attachments\" in item)) item.attachments = [];","\t\t\tthis._runHandler(\"itemDone\", null, item);","\t\t\titems.push(item);","\t\t}","\t\tthis.newItems = items;","\t\tthis.complete(true);","\t} else {","\t\tthis.complete(false, response);","\t}","}","","/**"," * Overload complete to report translation failure"," */","Zotero.Translate.Web.prototype.complete = function(returnValue, error) {","\t// call super","\tvar oldState = this._currentState;","\tvar errorString = Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","\t","\t// Report translation failure if we failed","\tif(oldState == \"translate\" && errorString && !this._parentTranslator && this.translator.length","\t\t&& this.translator[0].inRepository && Zotero.Prefs.get(\"reportTranslationFailure\")) {","\t\t// Don't report failure if in private browsing mode","\t\tif(Zotero.isFx && !Zotero.isBookmarklet && !Zotero.isStandalone && Components.classes[\"@mozilla.org/privatebrowsing;1\"]) {","\t\t\tvar pbs = Components.classes[\"@mozilla.org/privatebrowsing;1\"]","\t\t\t\t\t\t.getService(Components.interfaces.nsIPrivateBrowsingService);","\t\t\tif (pbs.privateBrowsingEnabled) {","\t\t\t\treturn;","\t\t\t}","\t\t}","\t\t","\t\tvar translator = this.translator[0];","\t\tZotero.getSystemInfo(function(info) {","\t\t\tvar postBody = \"id=\" + encodeURIComponent(translator.translatorID) +","\t\t\t\t\t\t   \"&lastUpdated=\" + encodeURIComponent(translator.lastUpdated) +","\t\t\t\t\t\t   \"&diagnostic=\" + encodeURIComponent(info) +","\t\t\t\t\t\t   \"&errorData=\" + encodeURIComponent(errorString);","\t\t\tZotero.HTTP.doPost(ZOTERO_CONFIG.REPOSITORY_URL + \"report\", postBody);","\t\t});","\t}","}","","/**"," * @class Import translation"," */","Zotero.Translate.Import = function() {","\tthis.init();","}","Zotero.Translate.Import.prototype = new Zotero.Translate.Base();","Zotero.Translate.Import.prototype.type = \"import\";","Zotero.Translate.Import.prototype._entryFunctionSuffix = \"Import\";","Zotero.Translate.Import.prototype._io = false;","","Zotero.Translate.Import.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Import);","","/**"," * Sets string for translation and initializes string IO"," */","Zotero.Translate.Import.prototype.setString = function(string) {","\tthis._string = string;","\tthis._io = false;","}","","/**"," * Overload {@link Zotero.Translate.Base#complete} to close file"," */","Zotero.Translate.Import.prototype.complete = function(returnValue, error) {","\tif(this._io) {","\t\tthis._progress = null;","\t\tthis._io.close(false);","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Get all potential import translators, ordering translators with the right file extension first"," */","Zotero.Translate.Import.prototype._getTranslatorsGetPotentialTranslators = function() {","\tif(this.location) {","\t\tvar me = this;","\t\tZotero.Translators.getImportTranslatorsForLocation(this.location,","\t\t\tfunction(translators) { me._getTranslatorsTranslatorsReceived(translators) });","\t} else {","\t\tZotero.Translate.Base.prototype._getTranslatorsGetPotentialTranslators.call(this);","\t}","}","","/**"," * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately only"," * if no string or location is set"," */","Zotero.Translate.Import.prototype.getTranslators = function() {","\tif(!this._string && !this.location) {","\t\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\t\tthis._currentState = \"detect\";","\t\tvar me = this;","\t\tZotero.Translators.getAllForType(this.type, function(translators) {","\t\t\tme._potentialTranslators = [];","\t\t\tme._foundTranslators = translators;","\t\t\tme.complete(true);","\t\t});","\t\tif(this._currentState === null) return this._foundTranslators;","\t} else {","\t\treturn Zotero.Translate.Base.prototype.getTranslators.call(this);","\t}","}","\t","/**"," * Overload {@link Zotero.Translate.Base#_loadTranslator} to prepare translator IO"," */","Zotero.Translate.Import.prototype._loadTranslator = function(translator, callback) {","\t// call super","\tvar me = this;","\tZotero.Translate.Base.prototype._loadTranslator.call(this, translator, function() {","\t\tme._loadTranslatorPrepareIO(translator, callback);","\t});","}","\t","/**"," * Prepare translator IO"," */","Zotero.Translate.Import.prototype._loadTranslatorPrepareIO = function(translator, callback) {","\tvar configOptions = this._translatorInfo.configOptions;","\tvar dataMode = configOptions ? configOptions[\"dataMode\"] : \"\";","\t","\tvar me = this;","\tvar initCallback = function(status, err) {","\t\tif(!status) {","\t\t\tme.complete(false, err);","\t\t} else {","\t\t\tme._sandboxManager.importObject(me._io);","\t\t\tif(callback) callback();","\t\t}","\t};","\t","\tvar err = false;","\tif(!this._io) {","\t\tif(Zotero.Translate.IO.Read && this.location && this.location instanceof Components.interfaces.nsIFile) {","\t\t\ttry {","\t\t\t\tthis._io = new Zotero.Translate.IO.Read(this.location, this._sandboxManager);","\t\t\t} catch(e) {","\t\t\t\terr = e;","\t\t\t}","\t\t} else {","\t\t\ttry {","\t\t\t\tthis._io = new Zotero.Translate.IO.String(this._string, this.path ? this.path : \"\", this._sandboxManager);","\t\t\t} catch(e) {","\t\t\t\terr = e;","\t\t\t}","\t\t}","\t","\t\tif(err) {","\t\t\tthis.complete(false, err);","\t\t\treturn;","\t\t}","\t}","\t","\ttry {","\t\tthis._io.init(dataMode, initCallback);","\t} catch(e) {","\t\terr = e;","\t}","\tif(err) {","\t\tthis.complete(false, err);","\t\treturn;","\t}","}","","/**"," * Prepare translation"," */","Zotero.Translate.Import.prototype._prepareTranslation = function() {","\tthis._progress = undefined;","\t","\tvar baseURI = null;","\tif(this.location) {","\t\ttry {","\t\t\tbaseURI = Components.classes[\"@mozilla.org/network/io-service;1\"].","\t\t\t\tgetService(Components.interfaces.nsIIOService).newFileURI(this.location);","\t\t} catch(e) {}","\t}","\t","\tthis._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,","\t\tZotero.Translate.ItemSaver[(this._saveAttachments ? \"ATTACHMENT_MODE_FILE\" : \"ATTACHMENT_MODE_IGNORE\")],","\t\tundefined, undefined, undefined, baseURI);","\tthis.newItems = [];","\tthis.newCollections = [];","}","","/**"," * Return the progress of the import operation, or null if progress cannot be determined"," */","Zotero.Translate.Import.prototype.getProgress = function() {","\tif(this._progress !== undefined) return this._progress;","\tif(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 || this._mode === \"xml/e4x\" || this._mode == \"xml/dom\" || !this._io) {","\t\treturn null;","\t}","\treturn this._io.bytesRead/this._io.contentLength*100;","};","\t","","/**"," * @class Export translation"," */","Zotero.Translate.Export = function() {","\tthis.init();","}","Zotero.Translate.Export.prototype = new Zotero.Translate.Base();","Zotero.Translate.Export.prototype.type = \"export\";","Zotero.Translate.Export.prototype._entryFunctionSuffix = \"Export\";","Zotero.Translate.Export.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Export);","","/**"," * Sets the items to be exported"," * @param {Zotero.Item[]} items"," */","Zotero.Translate.Export.prototype.setItems = function(items) {","\tthis._items = items;","\tdelete this._collection;","}","","/**"," * Sets the collection to be exported (overrides setItems)"," * @param {Zotero.Collection[]} collection"," */","Zotero.Translate.Export.prototype.setCollection = function(collection) {","\tthis._collection = collection;","\tdelete this._items;","}","","/**"," * Sets the translator to be used for export"," *"," * @param {Zotero.Translator|string} Translator object or ID. If this contains a displayOptions"," *    attribute, setDisplayOptions is automatically called with the specified value."," */","Zotero.Translate.Export.prototype.setTranslator = function(translator) {","\tif(typeof translator == \"object\" && translator.displayOptions) {","\t\tthis._displayOptions = translator.displayOptions;","\t}","\treturn Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);","}","","/**"," * Sets translator display options. you can also pass a translator (not ID) to"," * setTranslator that includes a displayOptions argument"," */","Zotero.Translate.Export.prototype.setDisplayOptions = function(displayOptions) {","\tthis._displayOptions = displayOptions;","}","","/**"," * Overload {@link Zotero.Translate.Base#complete} to close file and set complete"," */","Zotero.Translate.Export.prototype.complete = function(returnValue, error) {","\tif(this._io) {","\t\tthis._progress = null;","\t\tthis._io.close(true);","\t\tif(this._io instanceof Zotero.Translate.IO.String) {","\t\t\tthis.string = this._io.string;","\t\t}","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately"," */","Zotero.Translate.Export.prototype.getTranslators = function() {","\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\tthis._currentState = \"detect\";","\tthis._foundTranslators = Zotero.Translators.getAllForType(this.type);","\tthis._potentialTranslators = [];","\tthis.complete(true);","\treturn this._foundTranslators;","}","","/**"," * Does the actual export, after code has been loaded and parsed"," */","Zotero.Translate.Export.prototype._prepareTranslation = function() {","\tthis._progress = undefined;","\t","\t// initialize ItemGetter","\tthis._itemGetter = new Zotero.Translate.ItemGetter();","\tvar configOptions = this._translatorInfo.configOptions || {},","\t\tgetCollections = configOptions.getCollections || false;","\tif(this._collection) {","\t\tthis._itemGetter.setCollection(this._collection, getCollections);","\t\tdelete this._collection;","\t} else if(this._items) {","\t\tthis._itemGetter.setItems(this._items);","\t\tdelete this._items;","\t} else {","\t\tthis._itemGetter.setAll(getCollections);","\t}","\t","\t// export file data, if requested","\tif(this._displayOptions[\"exportFileData\"]) {","\t\tthis.location = this._itemGetter.exportFiles(this.location, this.translator[0].target);","\t}","\t","\t// initialize IO","\t// this is currently hackish since we pass null callbacks to the init function (they have","\t// callbacks to be consistent with import, but they are synchronous, so we ignore them)","\tif(!this.location) {","\t\tthis._io = new Zotero.Translate.IO.String(null, this.path ? this.path : \"\", this._sandboxManager);","\t\tthis._io.init(configOptions[\"dataMode\"], function() {});","\t} else if(!Zotero.Translate.IO.Write) {","\t\tthrow new Error(\"Writing to files is not supported in this build of Zotero.\");","\t} else {","\t\tthis._io = new Zotero.Translate.IO.Write(this.location);","\t\tthis._io.init(configOptions[\"dataMode\"],","\t\t\tthis._displayOptions[\"exportCharset\"] ? this._displayOptions[\"exportCharset\"] : null,","\t\t\tfunction() {});","\t}","\t","\tthis._sandboxManager.importObject(this._io);","}","","/**"," * Overload Zotero.Translate.Base#translate to make sure that"," *   Zotero.Translate.Export#translate is not called without setting a"," *   translator first. Doesn't make sense to run detection for export."," */","Zotero.Translate.Export.prototype.translate = function() {","\tif(!this.translator || !this.translator.length) {","\t\tthis.complete(false, new Error(\"Export translation initiated without setting a translator\"));","\t} else {","\t\tZotero.Translate.Base.prototype.translate.apply(this, arguments);","\t}","};","","/**"," * Return the progress of the import operation, or null if progress cannot be determined"," */","Zotero.Translate.Export.prototype.getProgress = function() {","\tif(this._progress !== undefined) return this._progress;","\tif(!this._itemGetter) {","\t\treturn null;","\t}","\treturn (1-this._itemGetter.numItemsRemaining/this._itemGetter.numItems)*100;","};","","/**"," * @class Search translation"," * @property {Array[]} search Item (in {@link Zotero.Item#serialize} format) to extrapolate data"," *    (set with setSearch)"," */","Zotero.Translate.Search = function() {","\tthis.init();","};","Zotero.Translate.Search.prototype = new Zotero.Translate.Base();","Zotero.Translate.Search.prototype.type = \"search\";","Zotero.Translate.Search.prototype._entryFunctionSuffix = \"Search\";","Zotero.Translate.Search.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Search);","","/**"," * @borrows Zotero.Translate.Web#setCookieSandbox"," */","Zotero.Translate.Search.prototype.setCookieSandbox = Zotero.Translate.Web.prototype.setCookieSandbox;","","/**"," * Sets the item to be used for searching"," * @param {Object} item An item, with as many fields as desired, in the format returned by"," *     {@link Zotero.Item#serialize}"," */","Zotero.Translate.Search.prototype.setSearch = function(search) {","\tthis.search = search;","}","","/**"," * Overloads {@link Zotero.Translate.Base#getTranslators} to always return all potential translators"," */","Zotero.Translate.Search.prototype.getTranslators = function() {","\treturn Zotero.Translate.Base.prototype.getTranslators.call(this, true);","}","","/**"," * Sets the translator or translators to be used for search"," *"," * @param {Zotero.Translator|string} Translator object or ID"," */","Zotero.Translate.Search.prototype.setTranslator = function(translator) {","\tif(typeof translator == \"object\" && !translator.translatorID) {","\t\t// we have an array of translators","\t\t","\t\t// accept a list of objects","\t\tthis.translator = [];","\t\tfor(var i=0, n=translator.length; i<n; i++) {","\t\t\tthis.translator.push(translator[i]);","\t\t}","\t\treturn true;","\t} else {","\t\treturn Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);","\t}","}","","/**"," * Overload Zotero.Translate.Base#complete to move onto the next translator if"," * translation fails"," */","Zotero.Translate.Search.prototype.complete = function(returnValue, error) {","\tif(this._currentState == \"translate\" && (!this.newItems || !this.newItems.length)","\t\t&& this.translator.length) { //length is 0 only when translate was called without translators","\t\tZotero.debug(\"Translate: Could not find a result using \"+this.translator[0].label, 3);","\t\tif(error) Zotero.debug(this._generateErrorString(error), 3);","\t\tif(this.translator.length > 1) {","\t\t\tthis.translator.shift();","\t\t\tthis.translate(this._libraryID, this._saveAttachments);","\t\t\treturn;","\t\t} else {","\t\t\terror = \"No items returned from any translator\";","\t\t\treturnValue = false;","\t\t}","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Pass search item to detect* and do* functions"," */","Zotero.Translate.Search.prototype._getParameters = function() {","\tif(Zotero.isFx) {","\t\treturn [this._sandboxManager.copyObject(this.search)];","\t}","\treturn [this.search];","};","","/**"," * Extract sandbox location from translator target"," */","Zotero.Translate.Search.prototype._getSandboxLocation = function() {","\t// generate sandbox for search by extracting domain from translator target","\tif(this.translator && this.translator[0] && this.translator[0].target) {","\t\t// so that web translators work too","\t\tconst searchSandboxRe = /^http:\\/\\/[\\w.]+\\//;","\t\tvar tempURL = this.translator[0].target.replace(/\\\\/g, \"\").replace(/\\^/g, \"\");","\t\tvar m = searchSandboxRe.exec(tempURL);","\t\tif(m) return m[0];","\t}","\treturn Zotero.Translate.Base.prototype._getSandboxLocation.call(this);","}","","Zotero.Translate.Search.prototype._prepareTranslation = Zotero.Translate.Web.prototype._prepareTranslation;","","/**"," * IO-related functions"," * @namespace"," */","Zotero.Translate.IO = {","\t/**","\t * Parses XML using DOMParser","\t */","\t\"parseDOMXML\":function(input, charset, size) {","\t\ttry {","\t\t\tvar dp = new DOMParser();","\t\t} catch(e) {","\t\t\ttry {","\t\t\t\tvar dp = Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]","\t\t\t\t   .createInstance(Components.interfaces.nsIDOMParser);","\t\t\t} catch(e) {","\t\t\t\tthrow new Error(\"DOMParser not supported\");","\t\t\t}","\t\t}","\t\t","\t\tif(typeof input == \"string\") {","\t\t\tvar nodes = dp.parseFromString(input, \"text/xml\");","\t\t} else {","\t\t\tvar nodes = dp.parseFromStream(input, charset, size, \"text/xml\");","\t\t}","\t\t","\t\tif(nodes.getElementsByTagName(\"parsererror\").length) {","\t\t\tthrow \"DOMParser error: loading data into data store failed\";","\t\t}","\t\t","\t\tif(\"normalize\" in nodes) nodes.normalize();","\t\t","\t\treturn nodes;","\t},","\t","\t/**","\t * Names of RDF data modes","\t */","\t\"rdfDataModes\":[\"rdf\", \"rdf/xml\", \"rdf/n3\"]","};","","/******* String support *******/","","/**"," * @class Translate backend for translating from a string"," */","Zotero.Translate.IO.String = function(string, uri, sandboxManager) {","\tif(string && typeof string === \"string\") {","\t\tthis.string = string;","\t} else {","\t\tthis.string = \"\";","\t}","\tthis.contentLength = this.string.length;","\tthis.bytesRead = 0;","\tthis._uri = uri;","\tthis._sandboxManager = sandboxManager;","}","","Zotero.Translate.IO.String.prototype = {","\t\"__exposedProps__\":{","\t\t\"RDF\":\"r\",","\t\t\"read\":\"r\",","\t\t\"write\":\"r\",","\t\t\"setCharacterSet\":\"r\",","\t\t\"getXML\":\"r\"","\t},","\t","\t\"_initRDF\":function(callback) {","\t\tZotero.debug(\"Translate: Initializing RDF data store\");","\t\tthis._dataStore = new Zotero.RDF.AJAW.IndexedFormula();","\t\tthis.RDF = new Zotero.Translate.IO._RDFSandbox(this._dataStore);","\t\t","\t\tif(this.contentLength) {","\t\t\ttry {","\t\t\t\tvar xml = Zotero.Translate.IO.parseDOMXML(this.string);","\t\t\t} catch(e) {","\t\t\t\tthis._xmlInvalid = true;","\t\t\t\tthrow e;","\t\t\t}","\t\t\tvar parser = new Zotero.RDF.AJAW.RDFParser(this._dataStore);","\t\t\tparser.parse(xml, this._uri);","\t\t}","\t\tcallback(true);","\t},","\t","\t\"setCharacterSet\":function(charset) {},","\t","\t\"read\":function(bytes) {","\t\t// if we are reading in RDF data mode and no string is set, serialize current RDF to the","\t\t// string","\t\tif(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === \"\") {","\t\t\tthis.string = this.RDF.serialize();","\t\t}","\t\t","\t\t// return false if string has been read","\t\tif(this.bytesRead >= this.contentLength) {","\t\t\treturn false;","\t\t}","\t\t","\t\tif(bytes !== undefined) {","\t\t\tif(this.bytesRead >= this.contentLength) return false;","\t\t\tvar oldPointer = this.bytesRead;","\t\t\tthis.bytesRead += bytes;","\t\t\treturn this.string.substr(oldPointer, bytes);","\t\t} else {","\t\t\t// bytes not specified; read a line","\t\t\tvar oldPointer = this.bytesRead;","\t\t\tvar lfIndex = this.string.indexOf(\"\\n\", this.bytesRead);","\t\t\t","\t\t\tif(lfIndex !== -1) {","\t\t\t\t// in case we have a CRLF","\t\t\t\tthis.bytesRead = lfIndex+1;","\t\t\t\tif(this.contentLength > lfIndex && this.string.substr(lfIndex-1, 1) === \"\\r\") {","\t\t\t\t\tlfIndex--;","\t\t\t\t}","\t\t\t\treturn this.string.substr(oldPointer, lfIndex-oldPointer);\t\t\t\t\t","\t\t\t}","\t\t\t","\t\t\tif(!this._noCR) {","\t\t\t\tvar crIndex = this.string.indexOf(\"\\r\", this.bytesRead);","\t\t\t\tif(crIndex === -1) {","\t\t\t\t\tthis._noCR = true;","\t\t\t\t} else {","\t\t\t\t\tthis.bytesRead = crIndex+1;","\t\t\t\t\treturn this.string.substr(oldPointer, crIndex-oldPointer-1);","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\tthis.bytesRead = this.contentLength;","\t\t\treturn this.string.substr(oldPointer);","\t\t}","\t},","\t","\t\"write\":function(data) {","\t\tthis.string += data;","\t\tthis.contentLength = this.string.length;","\t},","\t","\t\"getXML\":function() {","\t\ttry {","\t\t\tvar xml = Zotero.Translate.IO.parseDOMXML(this.string);","\t\t} catch(e) {","\t\t\tthis._xmlInvalid = true;","\t\t\tthrow e;","\t\t}","\t\treturn (Zotero.isFx && !Zotero.isBookmarklet ? this._sandboxManager.wrap(xml) : xml);","\t},","\t","\t\"init\":function(newMode, callback) {","\t\tthis.bytesRead = 0;","\t\tthis._noCR = undefined;","\t\t","\t\tthis._mode = newMode;","\t\tif(newMode === \"xml/e4x\") {","\t\t\tthrow \"E4X is not supported\";","\t\t} else if(newMode && (Zotero.Translate.IO.rdfDataModes.indexOf(newMode) !== -1","\t\t\t\t|| newMode.substr(0, 3) === \"xml/dom\") && this._xmlInvalid) {","\t\t\tthrow \"XML known invalid\";","\t\t} else if(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1) {","\t\t\tthis._initRDF(callback);","\t\t} else {","\t\t\tcallback(true);","\t\t}","\t},","\t","\t\"close\":function(serialize) {","\t\t// if we are writing in RDF data mode and no string is set, serialize current RDF to the","\t\t// string","\t\tif(serialize && Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === \"\") {","\t\t\tthis.string = this.RDF.serialize();","\t\t}","\t}","}","","/****** RDF DATA MODE ******/","","/**"," * @class An API for handling RDF from the sandbox. This is exposed to translators as Zotero.RDF."," *"," * @property {Zotero.RDF.AJAW.IndexedFormula} _dataStore"," * @property {Integer[]} _containerCounts"," * @param {Zotero.RDF.AJAW.IndexedFormula} dataStore"," */","Zotero.Translate.IO._RDFSandbox = function(dataStore) {","\tthis._dataStore = dataStore;","}","","Zotero.Translate.IO._RDFSandbox.prototype = {","\t\"_containerCounts\":[],","\t\"__exposedProps__\":{","\t\t\"addStatement\":\"r\",","\t\t\"newResource\":\"r\",","\t\t\"newContainer\":\"r\",","\t\t\"addContainerElement\":\"r\",","\t\t\"getContainerElements\":\"r\",","\t\t\"addNamespace\":\"r\",","\t\t\"getAllResources\":\"r\",","\t\t\"getResourceURI\":\"r\",","\t\t\"getArcsIn\":\"r\",","\t\t\"getArcsOut\":\"r\",","\t\t\"getSources\":\"r\",","\t\t\"getTargets\":\"r\",","\t\t\"getStatementsMatching\":\"r\",","\t\t\"serialize\":\"r\"","\t},","\t","\t/**","\t * Gets a resource as a Zotero.RDF.AJAW.Symbol, rather than a string","\t * @param {String|Zotero.RDF.AJAW.Symbol} about","\t * @return {Zotero.RDF.AJAW.Symbol}","\t */","\t\"_getResource\":function(about) {","\t\treturn (typeof about == \"object\" ? about : new Zotero.RDF.AJAW.Symbol(about));","\t},","\t","\t/**","\t * Runs a callback to initialize this RDF store","\t */","\t\"_init\":function() {","\t\tif(this._prepFunction) {","\t\t\tthis._dataStore = this._prepFunction();","\t\t\tdelete this._prepFunction;","\t\t}","\t},","\t","\t/**","\t * Serializes the current RDF to a string","\t */","\t\"serialize\":function(dataMode) {","\t\tvar serializer = Zotero.RDF.AJAW.Serializer(this._dataStore);","\t\t","\t\tfor(var prefix in this._dataStore.namespaces) {","\t\t\tserializer.suggestPrefix(prefix, this._dataStore.namespaces[prefix]);","\t\t}","\t\t","\t\t// serialize in appropriate format","\t\tif(dataMode == \"rdf/n3\") {","\t\t\treturn serializer.statementsToN3(this._dataStore.statements);","\t\t}","\t\t","\t\treturn serializer.statementsToXML(this._dataStore.statements);","\t},","\t","\t/**","\t * Adds an RDF triple","\t * @param {String|Zotero.RDF.AJAW.Symbol} about","\t * @param {String|Zotero.RDF.AJAW.Symbol} relation","\t * @param {String|Zotero.RDF.AJAW.Symbol} value","\t * @param {Boolean} literal Whether value should be treated as a literal (true) or a resource","\t *     (false)","\t */","\t\"addStatement\":function(about, relation, value, literal) {","\t\tif(about === null || about === undefined) {","\t\t\tthrow new Error(\"about must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\tif(relation === null || relation === undefined) {","\t\t\tthrow new Error(\"relation must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\tif(value === null || value === undefined) {","\t\t\tthrow new Error(\"value must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\t","\t\tif(literal) {","\t\t\t// zap chars that Mozilla will mangle","\t\t\tvalue = value.toString().replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g, '');","\t\t} else {","\t\t\tvalue = this._getResource(value);","\t\t}","\t\t","\t\tthis._dataStore.add(this._getResource(about), this._getResource(relation), value);","\t},","\t","\t/**","\t * Creates a new anonymous resource","\t * @return {Zotero.RDF.AJAW.Symbol}","\t */","\t\"newResource\":function() {","\t\treturn new Zotero.RDF.AJAW.BlankNode();","\t},","\t","\t/**","\t * Creates a new container resource","\t * @param {String} type The type of the container (\"bag\", \"seq\", or \"alt\")","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The URI of the resource","\t * @return {Zotero.Translate.RDF.prototype.newContainer","\t */","\t\"newContainer\":function(type, about) {","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t\tconst containerTypes = {\"bag\":\"Bag\", \"seq\":\"Seq\", \"alt\":\"Alt\"};","\t\t","\t\ttype = type.toLowerCase();","\t\tif(!containerTypes[type]) {","\t\t\tthrow new Error(\"Invalid container type in Zotero.RDF.newContainer\");","\t\t}","\t\t","\t\tvar about = this._getResource(about);","\t\tthis.addStatement(about, rdf+\"type\", rdf+containerTypes[type], false);","\t\tthis._containerCounts[about.toNT()] = 1;","\t\t","\t\treturn about;","\t},","\t","\t/**","\t * Adds a new element to a container","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The container","\t * @param {String|Zotero.RDF.AJAW.Symbol} element The element to add to the container","\t * @param {Boolean} literal Whether element should be treated as a literal (true) or a resource","\t *     (false)","\t */","\t\"addContainerElement\":function(about, element, literal) {","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t","\t\tvar about = this._getResource(about);","\t\tthis._dataStore.add(about, new Zotero.RDF.AJAW.Symbol(rdf+\"_\"+(this._containerCounts[about.toNT()]++)), element, literal);","\t},","\t","\t/**","\t * Gets all elements within a container","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The container","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t */","\t\"getContainerElements\":function(about) {","\t\tconst liPrefix = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#_\";","\t\t","\t\tvar about = this._getResource(about);","\t\tvar statements = this._dataStore.statementsMatching(about);","\t\tvar containerElements = [];","\t\t","\t\t// loop over arcs out looking for list items","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\tvar statement = statements[i];","\t\t\tif(statement.predicate.uri.substr(0, liPrefix.length) == liPrefix) {","\t\t\t\tvar number = statement.predicate.uri.substr(liPrefix.length);","\t\t\t\t","\t\t\t\t// make sure these are actually numeric list items","\t\t\t\tvar intNumber = parseInt(number);","\t\t\t\tif(number == intNumber.toString()) {","\t\t\t\t\t// add to element array","\t\t\t\t\tcontainerElements[intNumber-1] = (statement.object.termType == \"literal\" ? statement.object.toString() : statement.object);","\t\t\t\t}","\t\t\t}","\t\t}","\t\t","\t\treturn containerElements;","\t},","\t","\t/**","\t * Adds a namespace for a specific URI","\t * @param {String} prefix Namespace prefix","\t * @param {String} uri Namespace URI","\t */","\t\"addNamespace\":function(prefix, uri) {","\t\tthis._dataStore.setPrefixForURI(prefix, uri);","\t},","\t","\t/**","\t * Gets the URI a specific resource","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource","\t * @return {String}","\t */","\t\"getResourceURI\":function(resource) {","\t\tif(typeof(resource) == \"string\") return resource;","\t\t","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t\tvar values = this.getTargets(resource, rdf + 'value');","\t\tif(values && values.length) return this.getResourceURI(values[0]);","\t\t","\t\tif(resource.uri) return resource.uri;","\t\tif(resource.toNT == undefined) throw new Error(\"Zotero.RDF: getResourceURI called on invalid resource\");","\t\treturn resource.toNT();","\t},","\t","\t/**","\t * Gets all resources in the RDF data store","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t */","\t\"getAllResources\":function() {","\t\tvar returnArray = [];","\t\tfor(var i in this._dataStore.subjectIndex) {","\t\t\treturnArray.push(this._dataStore.subjectIndex[i][0].subject);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all arcs (predicates) into a resource","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getArcsIn\":function(resource) {","\t\tvar statements = this._dataStore.objectIndex[this._dataStore.canon(this._getResource(resource))];","\t\tif(!statements) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].predicate.uri);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all arcs (predicates) out of a resource","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getArcsOut\":function(resource) {","\t\tvar statements = this._dataStore.subjectIndex[this._dataStore.canon(this._getResource(resource))];","\t\tif(!statements) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].predicate.uri);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all subjects whose predicates point to a resource","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject that predicates should point to","\t * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getSources\":function(resource, property) {","\t\tvar statements = this._dataStore.statementsMatching(undefined, this._getResource(property), this._getResource(resource));","\t\tif(!statements.length) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].subject);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all objects of a given subject with a given predicate","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject","\t * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getTargets\":function(resource, property) {","\t\tvar statements = this._dataStore.statementsMatching(this._getResource(resource), this._getResource(property));","\t\tif(!statements.length) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].object.termType == \"literal\" ? statements[i].object.toString() : statements[i].object);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets statements matching a certain pattern","\t *","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tsubj \t\tSubject","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tpredicate\tPredicate","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tobj\t\t\tObject","\t * @param\t{Boolean}\t\t\t\t\t\t\tobjLiteral\tWhether the object is a literal (as","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topposed to a URI)","\t * @param\t{Boolean}\t\t\t\t\t\t\tjustOne\t\tWhether to stop when a single result is","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tretrieved","\t */","\t\"getStatementsMatching\":function(subj, pred, obj, objLiteral, justOne) {","\t\tvar statements = this._dataStore.statementsMatching(","\t\t\t(subj ? this._getResource(subj) : undefined),","\t\t\t(pred ? this._getResource(pred) : undefined),","\t\t\t(obj ? (objLiteral ? objLiteral : this._getResource(obj)) : undefined),","\t\t\tundefined, justOne);","\t\tif(!statements.length) return false;","\t\t","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push([statements[i].subject, statements[i].predicate, (statements[i].object.termType == \"literal\" ? statements[i].object.toString() : statements[i].object)]);","\t\t}","\t\treturn returnArray;","\t}","};"]}],[{"start":{"row":0,"column":0},"end":{"row":2804,"column":2},"action":"remove","lines":["/*","    ***** BEGIN LICENSE BLOCK *****","    ","    Copyright © 2009 Center for History and New Media","                     George Mason University, Fairfax, Virginia, USA","                     http://zotero.org","    ","    This file is part of Zotero.","    ","    Zotero is free software: you can redistribute it and/or modify","    it under the terms of the GNU Affero General Public License as published by","    the Free Software Foundation, either version 3 of the License, or","    (at your option) any later version.","    ","    Zotero is distributed in the hope that it will be useful,","    but WITHOUT ANY WARRANTY; without even the implied warranty of","    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the","    GNU Affero General Public License for more details.","    ","    You should have received a copy of the GNU Affero General Public License","    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.","    ","    ***** END LICENSE BLOCK *****","*/","","/**"," * @class"," * Deprecated class for creating new Zotero.Translate instances<br/>"," * <br/>"," * New code should use Zotero.Translate.Web, Zotero.Translate.Import, Zotero.Translate.Export, or"," * Zotero.Translate.Search"," */","Zotero.Translate = function(type) {","\tZotero.debug(\"Translate: WARNING: new Zotero.Translate() is deprecated; please don't use this if you don't have to\");","\t// hack","\tvar translate = Zotero.Translate.newInstance(type);","\tfor(var i in translate) {","\t\tthis[i] = translate[i];","\t}","\tthis.constructor = translate.constructor;","\tthis.__proto__ = translate.__proto__;","}","","/**"," * Create a new translator by a string type"," */","Zotero.Translate.newInstance = function(type) {","\treturn new Zotero.Translate[type.substr(0, 1).toUpperCase()+type.substr(1).toLowerCase()];","}","","/**"," * Namespace for Zotero sandboxes"," * @namespace"," */","Zotero.Translate.Sandbox = {","\t/**","\t * Combines a sandbox with the base sandbox","\t */","\t\"_inheritFromBase\":function(sandboxToMerge) {","\t\tvar newSandbox = {};","\t\t","\t\tfor(var method in Zotero.Translate.Sandbox.Base) {","\t\t\tnewSandbox[method] = Zotero.Translate.Sandbox.Base[method];","\t\t}","\t\t","\t\tfor(var method in sandboxToMerge) {","\t\t\tnewSandbox[method] = sandboxToMerge[method];","\t\t}","\t\t","\t\treturn newSandbox;","\t},","\t","\t/**","\t * Base sandbox. These methods are available to all translators.","\t * @namespace","\t */","\t\"Base\": {","\t\t/**","\t\t * Called as {@link Zotero.Item#complete} from translators to save items to the database.","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox","\t\t */","\t\t\"_itemDone\":function(translate, item) {","\t\t\t//Zotero.debug(\"Translate: Saving item\");","\t\t\t","\t\t\t// warn if itemDone called after translation completed","\t\t\tif(translate._complete) {","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.Item#complete() called after Zotero.done(); please fix your code\", 2);","\t\t\t}","\t\t\t\t","\t\t\tconst allowedObjects = [\"complete\", \"attachments\", \"seeAlso\", \"creators\", \"tags\", \"notes\"];","\t\t\t","\t\t\tdelete item.complete;","\t\t\tfor(var i in item) {","\t\t\t\tvar val = item[i];","\t\t\t\tif(!val && val !== 0) {","\t\t\t\t\t// remove null, undefined, and false properties, and convert objects to strings","\t\t\t\t\tdelete item[i];","\t\t\t\t\tcontinue;","\t\t\t\t}","\t\t\t\t","\t\t\t\tvar type = typeof val;","\t\t\t\tvar isObject = type === \"object\" || type === \"xml\" || type === \"function\",","\t\t\t\t\tshouldBeObject = allowedObjects.indexOf(i) !== -1;","\t\t\t\tif(isObject && !shouldBeObject) {","\t\t\t\t\t// Convert things that shouldn't be objects to objects","\t\t\t\t\ttranslate._debug(\"Translate: WARNING: typeof \"+i+\" is \"+type+\"; converting to string\");","\t\t\t\t\titem[i] = val.toString();","\t\t\t\t} else if(shouldBeObject && !isObject) {","\t\t\t\t\ttranslate._debug(\"Translate: WARNING: typeof \"+i+\" is \"+type+\"; converting to array\");","\t\t\t\t\titem[i] = [val];","\t\t\t\t} else if(type === \"string\") {","\t\t\t\t\t// trim strings","\t\t\t\t\titem[i] = val.trim();","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\t// if we're not supposed to save the item or we're in a child translator,","\t\t\t// just return the item array","\t\t\tif(translate._libraryID === false || translate._parentTranslator) {","\t\t\t\ttranslate.newItems.push(item);","\t\t\t\ttranslate._runHandler(\"itemDone\", item, item);","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\t// We use this within the connector to keep track of items as they are saved","\t\t\tif(!item.id) item.id = Zotero.Utilities.randomString();","\t\t\t","\t\t\t// don't save documents as documents in connector, since we can't pass them around","\t\t\tif(Zotero.isConnector) {","\t\t\t\tvar attachments = item.attachments;","\t\t\t\tvar nAttachments = attachments.length;","\t\t\t\tfor(var j=0; j<nAttachments; j++) {","\t\t\t\t\tif(attachments[j].document) {","\t\t\t\t\t\tattachments[j].url = attachments[j].document.documentURI || attachments[j].document.URL;","\t\t\t\t\t\tattachments[j].mimeType = \"text/html\";","\t\t\t\t\t\tdelete attachments[j].document;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t","\t\t\t// Fire itemSaving event","\t\t\ttranslate._runHandler(\"itemSaving\", item);","\t\t\t","\t\t\tif(translate instanceof Zotero.Translate.Web) {","\t\t\t\t// For web translators, we queue saves","\t\t\t\ttranslate.saveQueue.push(item);","\t\t\t} else {","\t\t\t\t// Save items","\t\t\t\ttranslate._saveItems([item]);","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Gets translator options that were defined in displayOptions in translator header","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} option Option to be retrieved","\t\t */","\t\t\"getOption\":function(translate, option) {","\t\t\tif(typeof option !== \"string\") {","\t\t\t\tthrow(new Error(\"getOption: option must be a string\"));","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\treturn translate._displayOptions[option];","\t\t},","\t\t","\t\t/**","\t\t * Gets a hidden preference that can be defined by hiddenPrefs in translator header","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} pref Prefernce to be retrieved","\t\t */","\t\t\"getHiddenPref\":function(translate, pref) {","\t\t\tif(typeof(pref) != \"string\") {","\t\t\t\tthrow(new Error(\"getPref: preference must be a string\"));","\t\t\t}","","\t\t\tvar hp = translate._translatorInfo.hiddenPrefs || {};","","\t\t\tvar value;","\t\t\ttry {","\t\t\t\tvalue = Zotero.Prefs.get('translators.' + pref);","\t\t\t} catch(e) {}","","\t\t\treturn (value !== undefined ? value : hp[pref]);","\t\t},","\t\t","\t\t/**","\t\t * For loading other translators and accessing their methods","\t\t * ","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} type Translator type (\"web\", \"import\", \"export\", or \"search\")","\t\t * @returns {Object} A safeTranslator object, which operates mostly like Zotero.Translate","\t\t */\t ","\t\t\"loadTranslator\":function(translate, type) {","\t\t\tconst setDefaultHandlers = function(translate, translation) {","\t\t\t\tif(type !== \"export\"","\t\t\t\t\t&& (!translation._handlers['itemDone'] || !translation._handlers['itemDone'].length)) {","\t\t\t\t\ttranslation.setHandler(\"itemDone\", function(obj, item) {","\t\t\t\t\t\ttranslate.Sandbox._itemDone(translate, item);","\t\t\t\t\t});","\t\t\t\t}","\t\t\t\tif(!translation._handlers['selectItems'] || !translation._handlers['selectItems'].length) {","\t\t\t\t\ttranslation.setHandler(\"selectItems\", translate._handlers[\"selectItems\"]);","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\tif(typeof type !== \"string\") {","\t\t\t\tthrow(new Error(\"loadTranslator: type must be a string\"));","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\tZotero.debug(\"Translate: Creating translate instance of type \"+type+\" in sandbox\");","\t\t\tvar translation = Zotero.Translate.newInstance(type);","\t\t\ttranslation._parentTranslator = translate;","\t\t\t","\t\t\tif(translation instanceof Zotero.Translate.Export && !(translation instanceof Zotero.Translate.Export)) {","\t\t\t\tthrow(new Error(\"Only export translators may call other export translators\"));","\t\t\t}","\t\t\t","\t\t\t/**","\t\t\t * @class Wrapper for {@link Zotero.Translate} for safely calling another translator ","\t\t\t * from inside an existing translator","\t\t\t * @inner","\t\t\t */","\t\t\tvar safeTranslator = {};","\t\t\tsafeTranslator.__exposedProps__ = {","\t\t\t\t\"setSearch\":\"r\",","\t\t\t\t\"setDocument\":\"r\",","\t\t\t\t\"setHandler\":\"r\",","\t\t\t\t\"setString\":\"r\",","\t\t\t\t\"setTranslator\":\"r\",","\t\t\t\t\"getTranslators\":\"r\",","\t\t\t\t\"translate\":\"r\",","\t\t\t\t\"getTranslatorObject\":\"r\"","\t\t\t};","\t\t\tsafeTranslator.setSearch = function(arg) {","\t\t\t\tif(!Zotero.isBookmarklet) arg = JSON.parse(JSON.stringify(arg));","\t\t\t\treturn translation.setSearch(arg);","\t\t\t};","\t\t\tsafeTranslator.setDocument = function(arg) {","\t\t\t\tif (Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\tif (arg.wrappedJSObject && arg.wrappedJSObject.__wrappedObject) {","\t\t\t\t\t\targ = arg.wrappedJSObject.__wrappedObject;","\t\t\t\t\t}","\t\t\t\t\treturn translation.setDocument(new XPCNativeWrapper(arg));","\t\t\t\t} else {","\t\t\t\t\treturn translation.setDocument(arg);","\t\t\t\t}","\t\t\t};","\t\t\tvar errorHandlerSet = false;","\t\t\tsafeTranslator.setHandler = function(arg1, arg2) {","\t\t\t\tif(arg1 === \"error\") errorHandlerSet = true;","\t\t\t\ttranslation.setHandler(arg1, ","\t\t\t\t\tfunction(obj, item) {","\t\t\t\t\t\ttry {","\t\t\t\t\t\t\titem = item.wrappedJSObject ? item.wrappedJSObject : item;","\t\t\t\t\t\t\tif(arg1 == \"itemDone\") {","\t\t\t\t\t\t\t\titem.complete = translate._sandboxZotero.Item.prototype.complete;","\t\t\t\t\t\t\t} else if(arg1 == \"translators\" && Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\t\t\t\tvar translators = new translate._sandboxManager.sandbox.Array();","\t\t\t\t\t\t\t\ttranslators = translators.wrappedJSObject || translators;","\t\t\t\t\t\t\t\tfor (var i=0; i<item.length; i++) {","\t\t\t\t\t\t\t\t\ttranslators.push(item[i]);","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\titem = translators;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\targ2(obj, item);","\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\ttranslate.complete(false, e);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t);","\t\t\t};","\t\t\tsafeTranslator.setString = function(arg) { translation.setString(arg) };","\t\t\tsafeTranslator.setTranslator = function(arg) {","\t\t\t\tvar success = translation.setTranslator(arg);","\t\t\t\tif(!success) {","\t\t\t\t\tthrow new Error(\"Translator \"+translate.translator[0].translatorID+\" attempted to call invalid translatorID \"+arg);","\t\t\t\t}","\t\t\t};","\t\t\t","\t\t\tvar translatorsHandlerSet = false;","\t\t\tsafeTranslator.getTranslators = function() {","\t\t\t\tif(!translation._handlers[\"translators\"] || !translation._handlers[\"translators\"].length) {","\t\t\t\t\tif(Zotero.isConnector) {","\t\t\t\t\t\tthrow new Error('Translator must register a \"translators\" handler to '+","\t\t\t\t\t\t\t'call getTranslators() in this translation environment.');","\t\t\t\t\t} else {","\t\t\t\t\t\ttranslate._debug('COMPAT WARNING: Translator must register a \"translators\" handler to '+","\t\t\t\t\t\t\t'call getTranslators() in connector');","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif(!translatorsHandlerSet) {","\t\t\t\t\ttranslation.setHandler(\"translators\", function() {","\t\t\t\t\t\ttranslate.decrementAsyncProcesses(\"safeTranslator#getTranslators()\");","\t\t\t\t\t});","\t\t\t\t}","\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#getTranslators()\");","\t\t\t\treturn translation.getTranslators();","\t\t\t};","\t\t\t","\t\t\tvar doneHandlerSet = false;","\t\t\tsafeTranslator.translate = function() {","\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#translate()\");","\t\t\t\tsetDefaultHandlers(translate, translation);","\t\t\t\tif(!doneHandlerSet) {","\t\t\t\t\tdoneHandlerSet = true;","\t\t\t\t\ttranslation.setHandler(\"done\", function() { translate.decrementAsyncProcesses(\"safeTranslator#translate()\") });","\t\t\t\t}","\t\t\t\tif(!errorHandlerSet) {","\t\t\t\t\terrorHandlerSet = true;","\t\t\t\t\ttranslation.setHandler(\"error\", function(obj, error) { translate.complete(false, error) });","\t\t\t\t}","\t\t\t\treturn translation.translate(false);","\t\t\t};","\t\t\t","\t\t\tsafeTranslator.getTranslatorObject = function(callback) {","\t\t\t\tif(callback) {","\t\t\t\t\ttranslate.incrementAsyncProcesses(\"safeTranslator#getTranslatorObject()\");","\t\t\t\t} else {","\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: Translator must pass a callback to getTranslatorObject() to operate in connector\");","\t\t\t\t}","\t\t\t\t","\t\t\t\tvar sandbox;","\t\t\t\tvar haveTranslatorFunction = function(translator) {","\t\t\t\t\ttranslation.translator[0] = translator;","\t\t\t\t\ttranslation._loadTranslator(translator, function() {","\t\t\t\t\t\tif(Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t\t\t\t\t// do same origin check","\t\t\t\t\t\t\tvar secMan = Components.classes[\"@mozilla.org/scriptsecuritymanager;1\"]","\t\t\t\t\t\t\t\t.getService(Components.interfaces.nsIScriptSecurityManager);","\t\t\t\t\t\t\tvar ioService = Components.classes[\"@mozilla.org/network/io-service;1\"] ","\t\t\t\t\t\t\t\t.getService(Components.interfaces.nsIIOService);","\t\t\t\t\t\t\t","\t\t\t\t\t\t\tvar outerSandboxURI = ioService.newURI(typeof translate._sandboxLocation === \"object\" ?","\t\t\t\t\t\t\t\ttranslate._sandboxLocation.location : translate._sandboxLocation, null, null);","\t\t\t\t\t\t\tvar innerSandboxURI = ioService.newURI(typeof translation._sandboxLocation === \"object\" ?","\t\t\t\t\t\t\t\ttranslation._sandboxLocation.location : translation._sandboxLocation, null, null);","\t\t\t\t\t\t\t","\t\t\t\t\t\t\ttry {","\t\t\t\t\t\t\t\tsecMan.checkSameOriginURI(outerSandboxURI, innerSandboxURI, false);","\t\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\t\tthrow new Error(\"getTranslatorObject() may not be called from web or search \"+","\t\t\t\t\t\t\t\t\t\"translators to web or search translators from different origins.\");","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\t","\t\t\t\t\t\ttranslation._prepareTranslation();","\t\t\t\t\t\tsetDefaultHandlers(translate, translation);","\t\t\t\t\t\tsandbox = translation._sandboxManager.sandbox;","\t\t\t\t\t\tif(!Zotero.Utilities.isEmpty(sandbox.exports)) {","\t\t\t\t\t\t\tsandbox.exports.Zotero = sandbox.Zotero;","\t\t\t\t\t\t\tsandbox = sandbox.exports;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: \"+translation.translator[0].label+\" does \"+","\t\t\t\t\t\t\t\t\"not export any properties. Only detect\"+translation._entryFunctionSuffix+","\t\t\t\t\t\t\t\t\" and do\"+translation._entryFunctionSuffix+\" will be available in \"+","\t\t\t\t\t\t\t\t\"connectors.\");","\t\t\t\t\t\t}","\t\t\t\t\t\t","\t\t\t\t\t\tif(callback) {","\t\t\t\t\t\t\ttry {","\t\t\t\t\t\t\t\tcallback(sandbox);","\t\t\t\t\t\t\t} catch(e) {","\t\t\t\t\t\t\t\ttranslate.complete(false, e);","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\ttranslate.decrementAsyncProcesses(\"safeTranslator#getTranslatorObject()\");","\t\t\t\t\t\t}","\t\t\t\t\t});","\t\t\t\t};","\t\t\t\t","\t\t\t\tif(typeof translation.translator[0] === \"object\") {","\t\t\t\t\thaveTranslatorFunction(translation.translator[0]);","\t\t\t\t\treturn translation._sandboxManager.sandbox;","\t\t\t\t} else {","\t\t\t\t\tif(Zotero.isConnector && (!Zotero.isFx || Zotero.isBookmarklet) && !callback) {","\t\t\t\t\t\tthrow new Error(\"Translator must pass a callback to getTranslatorObject() to \"+","\t\t\t\t\t\t\t\"operate in this translation environment.\");","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tZotero.Translators.get(translation.translator[0], haveTranslatorFunction);","\t\t\t\t\tif(Zotero.isConnector && Zotero.isFx && !callback) {","\t\t\t\t\t\twhile(!sandbox && translate._currentState) {","\t\t\t\t\t\t\t// This processNextEvent call is used to handle a deprecated case","\t\t\t\t\t\t\tZotero.mainThread.processNextEvent(true);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tif(sandbox) return sandbox;","\t\t\t\t}","\t\t\t};","","\t\t\tif(Zotero.isFx && Zotero.platformMajorVersion >= 33) {","\t\t\t\tfor(var i in safeTranslator) {","\t\t\t\t\tif (typeof(safeTranslator[i]) === \"function\") {","\t\t\t\t\t\tsafeTranslator[i] = translate._sandboxManager._makeContentForwarder(function(func) {","\t\t\t\t\t\t\treturn function() {","\t\t\t\t\t\t\t\tfunc.apply(safeTranslator, this.args.wrappedJSObject || this.args);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}(safeTranslator[i]));","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\treturn safeTranslator;","\t\t},","\t\t","\t\t/**","\t\t * Enables asynchronous detection or translation","\t\t * @param {Zotero.Translate} translate","\t\t * @deprecated","\t\t */","\t\t\"wait\":function(translate) {},","\t\t","\t\t/**","\t\t * Sets the return value for detection","\t\t *","\t\t * @param {Zotero.Translate} translate","\t\t */","\t\t\"done\":function(translate, returnValue) {","\t\t\tif(translate._currentState === \"detect\") {","\t\t\t\ttranslate._returnValue = returnValue;","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Proxy for translator _debug function","\t\t * ","\t\t * @param {Zotero.Translate} translate","\t\t * @param {String} string String to write to console","\t\t * @param {String} [level] Level to log as (1 to 5)","\t\t */","\t\t\"debug\":function(translate, string, level) {","\t\t\ttranslate._debug(string, level);","\t\t}","\t},","\t","\t/**","\t * Web functions exposed to sandbox","\t * @namespace","\t */","\t\"Web\":{","\t\t/**","\t\t * Lets user pick which items s/he wants to put in his/her library","\t\t * @param {Zotero.Translate} translate","\t\t * @param {Object} items An set of id => name pairs in object format","\t\t */","\t\t\"selectItems\":function(translate, items, callback) {","\t\t\tfunction transferObject(obj) {","\t\t\t\treturn Zotero.isFx ? translate._sandboxManager.copyObject(obj) : obj;","\t\t\t}","\t\t\t","\t\t\tif(Zotero.Utilities.isEmpty(items)) {","\t\t\t\tthrow new Error(\"Translator called select items with no items\");","\t\t\t}","\t\t\t","\t\t\t// Some translators pass an array rather than an object to Zotero.selectItems.","\t\t\t// This will break messaging outside of Firefox, so we need to fix it.","\t\t\tif(Object.prototype.toString.call(items) === \"[object Array]\") {","\t\t\t\ttranslate._debug(\"WARNING: Zotero.selectItems should be called with an object, not an array\");","\t\t\t\tvar itemsObj = {};","\t\t\t\tfor(var i in items) itemsObj[i] = items[i];","\t\t\t\titems = itemsObj;","\t\t\t}","\t\t\t","\t\t\tif(translate._selectedItems) {","\t\t\t\t// if we have a set of selected items for this translation, use them","\t\t\t\treturn transferObject(translate._selectedItems);","\t\t\t} else if(translate._handlers.select) {","\t\t\t\t\t// whether the translator supports asynchronous selectItems","\t\t\t\t\tvar haveAsyncCallback = !!callback;","\t\t\t\t\t// whether the handler operates asynchronously","\t\t\t\t\tvar haveAsyncHandler = false;","\t\t\t\t\tvar returnedItems = null;","\t\t\t\t\t","\t\t\t\t\tvar callbackExecuted = false;","\t\t\t\t\tif(haveAsyncCallback) {","\t\t\t\t\t\t// if this translator provides an async callback for selectItems, rig things","\t\t\t\t\t\t// up to pop off the async process","\t\t\t\t\t\tvar newCallback = function(selectedItems) {","\t\t\t\t\t\t\tcallbackExecuted = true;","\t\t\t\t\t\t\tcallback(transferObject(selectedItems));","\t\t\t\t\t\t\tif(haveAsyncHandler) translate.decrementAsyncProcesses(\"Zotero.selectItems()\");","\t\t\t\t\t\t};","\t\t\t\t\t} else {","\t\t\t\t\t\t// if this translator doesn't provide an async callback for selectItems, set things","\t\t\t\t\t\t// up so that we can wait to see if the select handler returns synchronously. If it","\t\t\t\t\t\t// doesn't, we will need to restart translation.","\t\t\t\t\t\tvar newCallback = function(selectedItems) {","\t\t\t\t\t\t\tcallbackExecuted = true;","\t\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t\ttranslate.translate(translate._libraryID, translate._saveAttachments, selectedItems);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\treturnedItems = transferObject(selectedItems);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t};","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tvar returnValue = translate._runHandler(\"select\", items, newCallback);","\t\t\t\t\tif(returnValue !== undefined) {","\t\t\t\t\t\t// handler may have returned a value, which makes callback unnecessary","\t\t\t\t\t\tZotero.debug(\"WARNING: Returning items from a select handler is deprecated. \"+","\t\t\t\t\t\t\t\"Please pass items as to the callback provided as the third argument to \"+","\t\t\t\t\t\t\t\"the handler.\");","\t\t\t\t\t\t","\t\t\t\t\t\treturnedItems = transferObject(returnValue);","\t\t\t\t\t\thaveAsyncHandler = false;","\t\t\t\t\t} else {","\t\t\t\t\t\t// if we don't have returnedItems set already, the handler is asynchronous","\t\t\t\t\t\thaveAsyncHandler = !callbackExecuted;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(haveAsyncCallback) {","\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t// we are running asynchronously, so increment async processes","\t\t\t\t\t\t\ttranslate.incrementAsyncProcesses(\"Zotero.selectItems()\");","\t\t\t\t\t\t} else if(!callbackExecuted) {","\t\t\t\t\t\t\t// callback didn't get called from handler, so call it here","\t\t\t\t\t\t\tcallback(returnedItems);","\t\t\t\t\t\t}","\t\t\t\t\t\treturn false;","\t\t\t\t\t} else {","\t\t\t\t\t\ttranslate._debug(\"COMPAT WARNING: No callback was provided for \"+","\t\t\t\t\t\t\t\"Zotero.selectItems(). When executed outside of Firefox, a selectItems() call \"+","\t\t\t\t\t\t\t\"will require this translator to be called multiple times.\", 1);","\t\t\t\t\t\t","\t\t\t\t\t\tif(haveAsyncHandler) {","\t\t\t\t\t\t\t// The select handler is asynchronous, but this translator doesn't support","\t\t\t\t\t\t\t// asynchronous select. We return false to abort translation in this","\t\t\t\t\t\t\t// instance, and we will restart it later when the selectItems call is","\t\t\t\t\t\t\t// complete.","\t\t\t\t\t\t\ttranslate._aborted = true;","\t\t\t\t\t\t\treturn false;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\treturn returnedItems;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t} else { // no handler defined; assume they want all of them","\t\t\t\tif(callback) callback(items);","\t\t\t\treturn items;","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Overloads {@link Zotero.Translate.Sandbox.Base._itemDone} to ensure that no standalone","\t\t * items are saved, that an item type is specified, and to add a libraryCatalog and ","\t\t * shortTitle if relevant.","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox","\t\t */","\t\t \"_itemDone\":function(translate, item) {","\t\t \t// Only apply checks if there is no parent translator","\t\t \tif(!translate._parentTranslator) {","\t\t\t\tif(!item.itemType) {","\t\t\t\t\titem.itemType = \"webpage\";","\t\t\t\t\ttranslate._debug(\"WARNING: No item type specified\");","\t\t\t\t}","\t\t\t\t","\t\t\t\tif(item.type == \"attachment\" || item.type == \"note\") {","\t\t\t\t\tZotero.debug(\"Translate: Discarding standalone \"+item.type+\" in non-import translator\", 2);","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// store library catalog if this item was captured from a website, and","\t\t\t\t// libraryCatalog is truly undefined (not false or \"\")","\t\t\t\tif(item.repository !== undefined) {","\t\t\t\t\tZotero.debug(\"Translate: 'repository' field is now 'libraryCatalog'; please fix your code\", 2);","\t\t\t\t\titem.libraryCatalog = item.repository;","\t\t\t\t\tdelete item.repository;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// automatically set library catalog","\t\t\t\tif(item.libraryCatalog === undefined) {","\t\t\t\t\titem.libraryCatalog = translate.translator[0].label;","\t\t\t\t}","\t\t\t\t\t\t\t","\t\t\t\t// automatically set access date if URL is set","\t\t\t\tif(item.url && typeof item.accessDate == 'undefined') {","\t\t\t\t\titem.accessDate = \"CURRENT_TIMESTAMP\";","\t\t\t\t}","\t\t\t\t","\t\t\t\t//consider type-specific \"title\" alternatives","\t\t\t\tvar altTitle = Zotero.ItemFields.getName(Zotero.ItemFields.getFieldIDFromTypeAndBase(item.itemType, 'title'));","\t\t\t\tif(altTitle && item[altTitle]) item.title = item[altTitle];","\t\t\t\t","\t\t\t\tif(!item.title) {","\t\t\t\t\ttranslate.complete(false, new Error(\"No title specified for item\"));","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// create short title","\t\t\t\tif(item.shortTitle === undefined && Zotero.Utilities.fieldIsValidForType(\"shortTitle\", item.itemType)) {\t\t","\t\t\t\t\t// only set if changes have been made","\t\t\t\t\tvar setShortTitle = false;","\t\t\t\t\tvar title = item.title;","\t\t\t\t\t","\t\t\t\t\t// shorten to before first colon","\t\t\t\t\tvar index = title.indexOf(\":\");","\t\t\t\t\tif(index !== -1) {","\t\t\t\t\t\ttitle = title.substr(0, index);","\t\t\t\t\t\tsetShortTitle = true;","\t\t\t\t\t}","\t\t\t\t\t// shorten to after first question mark","\t\t\t\t\tindex = title.indexOf(\"?\");","\t\t\t\t\tif(index !== -1) {","\t\t\t\t\t\tindex++;","\t\t\t\t\t\tif(index != title.length) {","\t\t\t\t\t\t\ttitle = title.substr(0, index);","\t\t\t\t\t\t\tsetShortTitle = true;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(setShortTitle) item.shortTitle = title;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// refuse to save very long tags","\t\t\t\tif(item.tags) {","\t\t\t\t\tfor(var i=0; i<item.tags.length; i++) {","\t\t\t\t\t\tvar tag = item.tags[i];","\t\t\t\t\t\t\ttagString = typeof tag === \"string\" ? tag :","\t\t\t\t\t\t\t\ttypeof tag === \"object\" ? (tag.tag || tag.name) : null;","\t\t\t\t\t\tif(tagString && tagString.length > 255) {","\t\t\t\t\t\t\ttranslate._debug(\"WARNING: Skipping unsynchable tag \"+JSON.stringify(tagString));","\t\t\t\t\t\t\titem.tags.splice(i--, 1);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t","\t\t\t\tfor(var i=0; i<item.attachments.length; i++) {","\t\t\t\t\tvar attachment = item.attachments[i];","\t\t\t\t\t","\t\t\t\t\t// Web translators are not allowed to use attachment.path","\t\t\t\t\tif (attachment.path) {","\t\t\t\t\t\tif (!attachment.url) attachment.url = attachment.path;","\t\t\t\t\t\tdelete attachment.path;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tif(attachment.url) {","\t\t\t\t\t\t// Remap attachment (but not link) URLs","\t\t\t\t\t\tattachment.url = translate.resolveURL(attachment.url, attachment.snapshot === false);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\t// call super","\t\t\tZotero.Translate.Sandbox.Base._itemDone(translate, item);","\t\t},","\t\t","\t\t/**","\t\t * Tells Zotero to monitor changes to the DOM and re-trigger detectWeb","\t\t * Can only be set during the detectWeb call","\t\t * @param {DOMNode} target Document node to monitor for changes","\t\t * @param {MutationObserverInit} [config] specifies which DOM mutations should be reported","\t\t */","\t\t\"monitorDOMChanges\":function(translate, target, config) {","\t\t\tif(translate._currentState != \"detect\") {","\t\t\t\tZotero.debug(\"Translate: monitorDOMChanges can only be called during the 'detect' stage\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar window = translate.document.defaultView","\t\t\tvar mutationObserver = window && ( window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver );","\t\t\tif(!mutationObserver) {","\t\t\t\tZotero.debug(\"Translate: This browser does not support mutation observers.\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar translator = translate._potentialTranslators[0];","\t\t\tif(!translate._registeredDOMObservers[translator.translatorID])","\t\t\t\ttranslate._registeredDOMObservers[translator.translatorID] = [];","\t\t\tvar obs = translate._registeredDOMObservers[translator.translatorID];","","\t\t\t//do not re-register observer by the same translator for the same node","\t\t\tif(obs.indexOf(target) != -1) {","\t\t\t\tZotero.debug(\"Translate: Already monitoring this node\");","\t\t\t\treturn;","\t\t\t}","","\t\t\tobs.push(target);","","\t\t\tvar observer = new mutationObserver(function(mutations, observer) {","\t\t\t\tobs.splice(obs.indexOf(target),1);","\t\t\t\tobserver.disconnect();","\t\t\t\t","\t\t\t\tZotero.debug(\"Translate: Page modified.\");","\t\t\t\t//we don't really care what got updated","\t\t\t\tvar doc = mutations[0].target.ownerDocument;","\t\t\t\ttranslate._runHandler(\"pageModified\", doc);","\t\t\t});","","\t\t\tobserver.observe(target, config || {childList: true, subtree: true});","\t\t\tZotero.debug(\"Translate: Mutation observer registered on <\" + target.nodeName + \"> node\");","\t\t}","\t},","","\t/**","\t * Import functions exposed to sandbox","\t * @namespace","\t */","\t\"Import\":{","\t\t/**","\t\t * Saves a collection to the DB","\t\t * Called as {@link Zotero.Collection#complete} from the sandbox","\t\t * @param {Zotero.Translate} translate","\t\t * @param {SandboxCollection} collection","\t\t */","\t\t\"_collectionDone\":function(translate, collection) {","\t\t\tif(translate._libraryID == false) {","\t\t\t\ttranslate.newCollections.push(collection);","\t\t\t\ttranslate._runHandler(\"collectionDone\", collection);","\t\t\t} else {","\t\t\t\tvar newCollection = translate._itemSaver.saveCollection(collection);","\t\t\t\ttranslate.newCollections.push(newCollection);","\t\t\t\ttranslate._runHandler(\"collectionDone\", newCollection);","\t\t\t}","\t\t},","\t\t","\t\t/**","\t\t * Sets the value of the progress indicator associated with export as a percentage","\t\t * @param {Zotero.Translate} translate","\t\t * @param {Number} value","\t\t */","\t\t\"setProgress\":function(translate, value) {","\t\t\tif(typeof value !== \"number\") {","\t\t\t\ttranslate._progress = null;","\t\t\t} else {","\t\t\t\ttranslate._progress = value;","\t\t\t}","\t\t}","\t},","","\t/**","\t * Export functions exposed to sandbox","\t * @namespace","\t */","\t\"Export\":{","\t\t/**","\t\t * Retrieves the next item to be exported","\t\t * @param {Zotero.Translate} translate","\t\t * @return {SandboxItem}","\t\t */","\t\t\"nextItem\":function(translate) {","\t\t\tvar item = translate._itemGetter.nextItem();","\t\t\t","\t\t\tif(translate._displayOptions.hasOwnProperty(\"exportTags\") && !translate._displayOptions[\"exportTags\"]) {","\t\t\t\titem.tags = [];","\t\t\t}","\t\t\t","\t\t\ttranslate._runHandler(\"itemDone\", item);","\t\t\t","\t\t\treturn item;","\t\t},","\t\t","\t\t/**","\t\t * Retrieves the next collection to be exported","\t\t * @param {Zotero.Translate} translate","\t\t * @return {SandboxCollection}","\t\t */","\t\t\"nextCollection\":function(translate) {","\t\t\tif(!translate._translatorInfo.configOptions || !translate._translatorInfo.configOptions.getCollections) {","\t\t\t\tthrow(new Error(\"getCollections configure option not set; cannot retrieve collection\"));","\t\t\t}","\t\t\t","\t\t\treturn translate._itemGetter.nextCollection();","\t\t},","\t\t","\t\t/**","\t\t * @borrows Zotero.Translate.Sandbox.Import.setProgress as this.setProgress","\t\t */","\t\t\"setProgress\":function(translate, value) {","\t\t\tZotero.Translate.Sandbox.Import.setProgress(translate, value);","\t\t}","\t},","\t","\t/**","\t * Search functions exposed to sandbox","\t * @namespace","\t */","\t\"Search\":{","\t\t/**","\t\t * @borrows Zotero.Translate.Sandbox.Web._itemDone as this._itemDone","\t\t */","\t\t\"_itemDone\":function(translate, item) {","\t\t\t// Always set library catalog, even if we have a parent translator","\t\t\tif(item.libraryCatalog === undefined) {","\t\t\t\titem.libraryCatalog = translate.translator[0].label;","\t\t\t}","\t\t\t","\t\t\tZotero.Translate.Sandbox.Web._itemDone(translate, item);","\t\t}","\t}","}","","/**"," * @class Base class for all translation types"," *"," * @property {String} type The type of translator. This is deprecated; use instanceof instead."," * @property {Zotero.Translator[]} translator The translator currently in use. Usually, only the"," *     first entry of the Zotero.Translator array is populated; subsequent entries represent"," *     translators to be used if the first fails."," * @property {String} path The path or URI string of the target"," * @property {String} newItems Items created when translate() was called"," * @property {String} newCollections Collections created when translate() was called"," * @property {Number} runningAsyncProcesses The number of async processes that are running. These"," *                                          need to terminate before Zotero.done() is called."," */","Zotero.Translate.Base = function() {}","Zotero.Translate.Base.prototype = {","\t/**","\t * Initializes a Zotero.Translate instance","\t */","\t\"init\":function() {","\t\tthis._handlers = [];","\t\tthis._currentState = null;","\t\tthis._translatorInfo = null;","\t\tthis.document = null;","\t\tthis.location = null;","\t},","\t","\t/**","\t * Sets the location to operate upon","\t *","\t * @param {String|nsIFile} location The URL to which the sandbox should be bound or path to local file","\t */","\t\"setLocation\":function(location) {","\t\tthis.location = location;","\t\tif(typeof this.location == \"object\") {\t// if a file","\t\t\tthis.path = location.path;","\t\t} else {\t\t\t\t\t\t\t\t// if a url","\t\t\tthis.path = location;","\t\t}","\t},","\t","\t/**","\t * Sets the translator to be used for import/export","\t *","\t * @param {Zotero.Translator|string} Translator object or ID","\t */","\t\"setTranslator\":function(translator) {","\t\tif(!translator) {","\t\t\tthrow new Error(\"No translator specified\");","\t\t}","\t\t","\t\tthis.translator = null;","\t\t","\t\tif(typeof(translator) == \"object\") {\t// passed an object and not an ID","\t\t\tif(translator.translatorID) {","\t\t\t\tthis.translator = [translator];","\t\t\t} else {","\t\t\t\tthrow(new Error(\"No translatorID specified\"));","\t\t\t}","\t\t} else {","\t\t\tthis.translator = [translator];","\t\t}","\t\t","\t\treturn !!this.translator;","\t},","\t","\t/**","\t * Registers a handler function to be called when translation is complete","\t *","\t * @param {String} type Type of handler to register. Legal values are:","\t * select","\t *   valid: web","\t *   called: when the user needs to select from a list of available items","\t *   passed: an associative array in the form id => text","\t *   returns: a numerically indexed array of ids, as extracted from the passed","\t *            string","\t * itemDone","\t *   valid: import, web, search","\t *   called: when an item has been processed; may be called asynchronously","\t *   passed: an item object (see Zotero.Item)","\t *   returns: N/A","\t * collectionDone","\t *   valid: import","\t *   called: when a collection has been processed, after all items have been","\t *           added; may be called asynchronously","\t *   passed: a collection object (see Zotero.Collection)","\t *   returns: N/A","\t * done","\t *   valid: all","\t *   called: when all processing is finished","\t *   passed: true if successful, false if an error occurred","\t *   returns: N/A","\t * debug","\t *   valid: all","\t *   called: when Zotero.debug() is called","\t *   passed: string debug message","\t *   returns: true if message should be logged to the console, false if not","\t * error","\t *   valid: all","\t *   called: when a fatal error occurs","\t *   passed: error object (or string)","\t *   returns: N/A","\t * translators","\t *   valid: all","\t *   called: when a translator search initiated with Zotero.Translate.getTranslators() is","\t *           complete","\t *   passed: an array of appropriate translators","\t *   returns: N/A","\t * pageModified","\t *   valid: web","\t *   called: when a web page has been modified","\t *   passed: the document object for the modified page","\t *   returns: N/A","\t * @param {Function} handler Callback function. All handlers will be passed the current","\t * translate instance as the first argument. The second argument is dependent on the handler.","\t */","\t\"setHandler\":function(type, handler) {","\t\tif(!this._handlers[type]) {","\t\t\tthis._handlers[type] = new Array();","\t\t}","\t\tthis._handlers[type].push(handler);","\t},","","\t/**","\t * Clears all handlers for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t */","\t\"clearHandlers\":function(type) {","\t\tthis._handlers[type] = new Array();","\t},","","\t/**","\t * Clears a single handler for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t * @param {Function} handler Callback function to remove","\t */","\t\"removeHandler\":function(type, handler) {","\t\tvar handlerIndex = this._handlers[type].indexOf(handler);","\t\tif(handlerIndex !== -1) this._handlers[type].splice(handlerIndex, 1);","\t},","\t","\t/**","\t * Indicates that a new async process is running","\t */","\t\"incrementAsyncProcesses\":function(f) {","\t\tthis._runningAsyncProcesses++;","\t\tif(this._parentTranslator) {","\t\t\tthis._parentTranslator.incrementAsyncProcesses(f+\" from child translator\");","\t\t} else {","\t\t\t//Zotero.debug(\"Translate: Incremented asynchronous processes to \"+this._runningAsyncProcesses+\" for \"+f, 4);","\t\t\t//Zotero.debug((new Error()).stack);","\t\t}","\t},","\t","\t/**","\t * Indicates that a new async process is finished","\t */","\t\"decrementAsyncProcesses\":function(f, by) {","\t\tthis._runningAsyncProcesses -= (by ? by : 1);","\t\tif(!this._parentTranslator) {","\t\t\t//Zotero.debug(\"Translate: Decremented asynchronous processes to \"+this._runningAsyncProcesses+\" for \"+f, 4);","\t\t\t//Zotero.debug((new Error()).stack);","\t\t}","\t\tif(this._runningAsyncProcesses === 0) {","\t\t\tthis.complete();","\t\t}","\t\tif(this._parentTranslator) this._parentTranslator.decrementAsyncProcesses(f+\" from child translator\", by);","\t},","","\t/**","\t * Clears all handlers for a given function","\t * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values","\t * @param {Any} argument Argument to be passed to handler","\t */","\t\"_runHandler\":function(type) {","\t\tvar returnValue = undefined;","\t\tif(this._handlers[type]) {","\t\t\t// compile list of arguments","\t\t\tif(this._parentTranslator) {","\t\t\t\t// if there is a parent translator, make sure we don't pass the Zotero.Translate","\t\t\t\t// object, since it could open a security hole","\t\t\t\tvar args = [null];","\t\t\t} else {","\t\t\t\tvar args = [this];","\t\t\t}","\t\t\tfor(var i=1; i<arguments.length; i++) {","\t\t\t\targs.push(arguments[i]);","\t\t\t}","\t\t\t","\t\t\tvar handlers = this._handlers[type].slice();","\t\t\tfor(var i=0, n=handlers.length; i<n; i++) {","\t\t\t\tZotero.debug(\"Translate: Running handler \"+i+\" for \"+type, 5);","\t\t\t\ttry {","\t\t\t\t\treturnValue = handlers[i].apply(null, args);","\t\t\t\t} catch(e) {","\t\t\t\t\tif(this._parentTranslator) {","\t\t\t\t\t\t// throw handler errors if they occur when a translator is","\t\t\t\t\t\t// called from another translator, so that the","\t\t\t\t\t\t// \"Could Not Translate\" dialog will appear if necessary","\t\t\t\t\t\tthrow(e);","\t\t\t\t\t} else {","\t\t\t\t\t\t// otherwise, fail silently, so as not to interfere with","\t\t\t\t\t\t// interface cleanup","\t\t\t\t\t\tZotero.debug(\"Translate: \"+e+' in handler '+i+' for '+type, 5);","\t\t\t\t\t\tZotero.logError(e);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn returnValue;","\t},","","\t/**","\t * Gets all applicable translators of a given type","\t *","\t * For import, you should call this after setLocation; otherwise, you'll just get a list of all","\t * import filters, not filters equipped to handle a specific file","\t *","\t * @param {Boolean} [getAllTranslators] Whether all applicable translators should be returned,","\t *     rather than just the first available.","\t * @param {Boolean} [checkSetTranslator] If true, the appropriate detect function is run on the","\t *     set document/text/etc. using the translator set by setTranslator.","\t *     getAllTranslators parameter is meaningless in this context.","\t * @return {Zotero.Translator[]} An array of {@link Zotero.Translator} objects","\t */","\t\"getTranslators\":function(getAllTranslators, checkSetTranslator) {","\t\t// do not allow simultaneous instances of getTranslators","\t\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\t\tthis._currentState = \"detect\";","\t\tthis._getAllTranslators = getAllTranslators;","","\t\tif(checkSetTranslator) {","\t\t\t// setTranslator must be called beforehand if checkSetTranslator is set","\t\t\tif( !this.translator || !this.translator[0] ) {","\t\t\t\tthrow new Error(\"getTranslators: translator must be set via setTranslator before calling\" +","\t\t\t\t\t\t\t\t\t\t\t\t\t\" getTranslators with the checkSetTranslator flag\");","\t\t\t}","\t\t\tvar translators = new Array();","\t\t\tvar t;","\t\t\tfor(var i=0, n=this.translator.length; i<n; i++) {","\t\t\t\tif(typeof(this.translator[i]) == 'string') {","\t\t\t\t\tt = Zotero.Translators.get(this.translator[i]);","\t\t\t\t\tif(!t) Zotero.debug(\"getTranslators: could not retrieve translator '\" + this.translator[i] + \"'\");","\t\t\t\t} else {","\t\t\t\t\tt = this.translator[i];","\t\t\t\t}","\t\t\t\t/**TODO: check that the translator is of appropriate type?*/","\t\t\t\tif(t) translators.push(t);","\t\t\t}","\t\t\tif(!translators.length) throw new Error(\"getTranslators: no valid translators were set.\");","\t\t\tthis._getTranslatorsTranslatorsReceived(translators);","\t\t} else {","\t\t\tthis._getTranslatorsGetPotentialTranslators();","\t\t}","","\t\t// if detection returns immediately, return found translators","\t\tif(!this._currentState) return this._foundTranslators;","\t},","\t","\t/**","\t * Get all potential translators","\t * @return {Zotero.Translator[]}","\t */","\t\"_getTranslatorsGetPotentialTranslators\":function() {","\t\tvar me = this;","\t\tZotero.Translators.getAllForType(this.type,","\t\t\tfunction(translators) { me._getTranslatorsTranslatorsReceived(translators) });","\t},","\t","\t/**","\t * Called on completion of {@link #_getTranslatorsGetPotentialTranslators} call","\t */","\t\"_getTranslatorsTranslatorsReceived\":function(allPotentialTranslators, properToProxyFunctions) {","\t\tthis._potentialTranslators = [];","\t\tthis._foundTranslators = [];","\t\t","\t\t// this gets passed out by Zotero.Translators.getWebTranslatorsForLocation() because it is","\t\t// specific for each translator, but we want to avoid making a copy of a translator whenever","\t\t// possible.","\t\tthis._properToProxyFunctions = properToProxyFunctions ? properToProxyFunctions : null;","\t\tthis._waitingForRPC = false;","\t\t","\t\tfor(var i=0, n=allPotentialTranslators.length; i<n; i++) {","\t\t\tvar translator = allPotentialTranslators[i];","\t\t\tif(translator.runMode === Zotero.Translator.RUN_MODE_IN_BROWSER) {","\t\t\t\tthis._potentialTranslators.push(translator);","\t\t\t} else if(this instanceof Zotero.Translate.Web && Zotero.Connector) {","\t\t\t\tthis._waitingForRPC = true;","\t\t\t}","\t\t}","\t\t","\t\tif(this._waitingForRPC) {","\t\t\tvar me = this;","\t\t\tZotero.Connector.callMethod(\"detect\", {\"uri\":this.location.toString(),","\t\t\t\t\"cookie\":this.document.cookie,","\t\t\t\t\"html\":this.document.documentElement.innerHTML},","\t\t\t\tfunction(returnValue) { me._getTranslatorsRPCComplete(returnValue) });","\t\t}","\t\t","\t\tthis._detect();","\t},","\t","\t/**","\t * Called on completion of detect RPC for","\t * {@link Zotero.Translate.Base#_getTranslatorsTranslatorsReceived}","\t */","\t \"_getTranslatorsRPCComplete\":function(rpcTranslators) {","\t\tthis._waitingForRPC = false;","\t\t","\t\t// if there are translators, add them to the list of found translators","\t\tif(rpcTranslators) {","\t\t\tfor(var i=0, n=rpcTranslators.length; i<n; i++) {","\t\t\t\trpcTranslators[i].runMode = Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE;","\t\t\t}","\t\t\tthis._foundTranslators = this._foundTranslators.concat(rpcTranslators);","\t\t}","\t\t","\t\t// call _detectTranslatorsCollected to return detected translators","\t\tif(this._currentState === null) {","\t\t\tthis._detectTranslatorsCollected();","\t\t}","\t },","","\t/**","\t * Begins the actual translation. At present, this returns immediately for import/export","\t * translators, but new code should use {@link Zotero.Translate.Base#setHandler} to register a ","\t * \"done\" handler to determine when execution of web/search translators is complete.","\t *","\t * @param \t{NULL|Integer|FALSE}\t[libraryID=null]\t\tLibrary in which to save items,","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tor NULL for default library;","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif FALSE, don't save items","\t * @param \t{Boolean}\t\t\t\t[saveAttachments=true]\tExclude attachments (e.g., snapshots) on import","\t */","\t\"translate\":function(libraryID, saveAttachments) {\t\t// initialize properties specific to each translation","\t\tif(!this.translator || !this.translator.length) {","\t\t\tvar args = arguments;","\t\t\tZotero.debug(\"Translate: translate called without specifying a translator. Running detection first.\");","\t\t\tthis.setHandler('translators', function(me, translators) {","\t\t\t\tif(!translators.length) {","\t\t\t\t\tme.complete(false, \"Could not find an appropriate translator\");","\t\t\t\t} else {","\t\t\t\t\tme.setTranslator(translators);","\t\t\t\t\tZotero.Translate.Base.prototype.translate.apply(me, args);","\t\t\t\t}","\t\t\t});","\t\t\tthis.getTranslators();","\t\t\treturn;","\t\t}","\t\t","\t\tthis._currentState = \"translate\";","\t\t","\t\tthis._libraryID = libraryID;","\t\tthis._saveAttachments = saveAttachments === undefined || saveAttachments;","\t\tthis._savingAttachments = [];","\t\tthis._savingItems = 0;","\t\tthis._waitingForSave = false;","\t\t","\t\tvar me = this;","\t\tif(typeof this.translator[0] === \"object\") {","\t\t\t// already have a translator object, so use it","\t\t\tthis._loadTranslator(this.translator[0], function() { me._translateTranslatorLoaded() });","\t\t} else {","\t\t\t// need to get translator first","\t\t\tZotero.Translators.get(this.translator[0],","\t\t\t\t\tfunction(translator) {","\t\t\t\t\t\tme.translator[0] = translator;","\t\t\t\t\t\tme._loadTranslator(translator, function() { me._translateTranslatorLoaded() });","\t\t\t\t\t});","\t\t}","\t},","\t","\t/**","\t * Called when translator has been retrieved and loaded","\t */","\t\"_translateTranslatorLoaded\":function() {","\t\tif(!this.translator[0].code) {","\t\t\tthis.complete(false,","\t\t\t\tnew Error(\"Translator \"+this.translator[0].label+\" is unsupported within this environment\"));","\t\t\treturn;","\t\t}","\t\t","\t\t// set display options to default if they don't exist","\t\tif(!this._displayOptions) this._displayOptions = this._translatorInfo.displayOptions || {};","\t\t","\t\t// prepare translation","\t\tthis._prepareTranslation();","\t\t","\t\tZotero.debug(\"Translate: Beginning translation with \"+this.translator[0].label);","\t\t","\t\tthis.incrementAsyncProcesses(\"Zotero.Translate#translate()\");","\t\t","\t\t// translate","\t\ttry {","\t\t\tFunction.prototype.apply.call(this._sandboxManager.sandbox[\"do\"+this._entryFunctionSuffix], null, this._getParameters());","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn false;","\t\t}","\t\t","\t\tthis.decrementAsyncProcesses(\"Zotero.Translate#translate()\");","\t},","\t","\t/**","\t * Return the progress of the import operation, or null if progress cannot be determined","\t */","\t\"getProgress\":function() { return null },","","\t/**","\t * Translate a URL to a form that goes through the appropriate proxy, or","\t * convert a relative URL to an absolute one","\t *","\t * @param {String} url","\t * @param {Boolean} dontUseProxy If true, don't convert URLs to variants","\t *     that use the proxy","\t * @type String","\t * @private","\t */","\t\"resolveURL\":function(url, dontUseProxy) {","\t\tconst hostPortRe = /^((?:http|https|ftp):)\\/\\/([^\\/]+)/i;","\t\t// resolve local URL","\t\tvar resolved = \"\";","\t\t","\t\t// convert proxy to proper if applicable","\t\tif(hostPortRe.test(url)) {","\t\t\tif(this.translator && this.translator[0]","\t\t\t\t\t&& this.translator[0].properToProxy && !dontUseProxy) {","\t\t\t\tresolved = this.translator[0].properToProxy(url);","\t\t\t} else {","\t\t\t\tresolved = url;","\t\t\t}","\t\t} else if(Zotero.isFx) {","\t\t\tresolved = Components.classes[\"@mozilla.org/network/io-service;1\"].","\t\t\t\tgetService(Components.interfaces.nsIIOService).","\t\t\t\tnewURI(this.location, \"\", null).resolve(url);","\t\t} else if(Zotero.isNode) {","\t\t\tresolved = require('url').resolve(this.location, url);","\t\t} else {","\t\t\tvar a = document.createElement('a');","\t        a.href = url;","\t        resolved = a.href;","\t\t}","\t\t","\t\t/*var m = hostPortRe.exec(resolved);","\t\tif(!m) {","\t\t\tthrow new Error(\"Invalid URL supplied for HTTP request: \"+url);","\t\t} else if(this._translate.document && this._translate.document.location) {","\t\t\tvar loc = this._translate.document.location;","\t\t\tif(this._translate._currentState !== \"translate\" && loc","\t\t\t\t\t&& (m[1].toLowerCase() !== loc.protocol.toLowerCase()","\t\t\t\t\t|| m[2].toLowerCase() !== loc.host.toLowerCase())) {","\t\t\t\tthrow new Error(\"Attempt to access \"+m[1]+\"//\"+m[2]+\" from \"+loc.protocol+\"//\"+loc.host","\t\t\t\t\t+\" blocked: Cross-site requests are only allowed during translation\");","\t\t\t}","\t\t}*/","\t\t","\t\treturn resolved;","\t},","\t","\t/**","\t * Executed on translator completion, either automatically from a synchronous scraper or as","\t * done() from an asynchronous scraper. Finishes things up and calls callback function(s).","\t * @param {Boolean|String} returnValue An item type or a boolean true or false","\t * @param {String|Exception} [error] An error that occurred during translation.","\t * @returm {String|NULL} The exception serialized to a string, or null if translation","\t *     completed successfully.","\t */","\t\"complete\":function(returnValue, error) {","\t\t// allow translation to be aborted for re-running after selecting items","\t\tif(this._aborted) return;","\t\t","\t\t// Make sure this isn't called twice","\t\tif(this._currentState === null) {","\t\t\tif(!returnValue) {","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.done() called after translator completion with error\");","\t\t\t\tZotero.debug(error);","\t\t\t} else {","\t\t\t\tvar e = new Error();","\t\t\t\tZotero.debug(\"Translate: WARNING: Zotero.done() called after translation completion. This should never happen. Please examine the stack below.\");","\t\t\t\tZotero.debug(e.stack);","\t\t\t}","\t\t\treturn;","\t\t}","\t\t","\t\t// reset async processes and propagate them to parent","\t\tif(this._parentTranslator && this._runningAsyncProcesses) {","\t\t\tthis._parentTranslator.decrementAsyncProcesses(\"Zotero.Translate#complete\", this._runningAsyncProcesses);","\t\t}","\t\tthis._runningAsyncProcesses = 0;","\t\t","\t\tif(!returnValue && this._returnValue) returnValue = this._returnValue;","\t\t","\t\tvar errorString = null;","\t\tif(!returnValue && error) errorString = this._generateErrorString(error);","\t\t","\t\tif(this._currentState === \"detect\") {","\t\t\tif(this._potentialTranslators.length) {","\t\t\t\tvar lastTranslator = this._potentialTranslators.shift();","\t\t\t\tvar lastProperToProxyFunction = this._properToProxyFunctions ? this._properToProxyFunctions.shift() : null;","\t\t\t\t","\t\t\t\tif(returnValue) {","\t\t\t\t\tvar dupeTranslator = {\"properToProxy\":lastProperToProxyFunction};","\t\t\t\t\t","\t\t\t\t\tfor(var i in lastTranslator) dupeTranslator[i] = lastTranslator[i];","\t\t\t\t\tif(Zotero.isBookmarklet && returnValue === \"server\") {","\t\t\t\t\t\t// In the bookmarklet, the return value from detectWeb can be \"server\" to","\t\t\t\t\t\t// indicate the translator should be run on the Zotero server","\t\t\t\t\t\tdupeTranslator.runMode = Zotero.Translator.RUN_MODE_ZOTERO_SERVER;","\t\t\t\t\t} else {","\t\t\t\t\t\t// Usually the return value from detectWeb will be either an item type or","\t\t\t\t\t\t// the string \"multiple\"","\t\t\t\t\t\tdupeTranslator.itemType = returnValue;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\tthis._foundTranslators.push(dupeTranslator);","\t\t\t\t} else if(error) {","\t\t\t\t\tthis._debug(\"Detect using \"+lastTranslator.label+\" failed: \\n\"+errorString, 2);","\t\t\t\t}","\t\t\t}","\t\t\t\t","\t\t\tif(this._potentialTranslators.length && (this._getAllTranslators || !returnValue)) {","\t\t\t\t// more translators to try; proceed to next translator","\t\t\t\tthis._detect();","\t\t\t} else {","\t\t\t\tthis._currentState = null;","\t\t\t\tif(!this._waitingForRPC) this._detectTranslatorsCollected();","\t\t\t}","\t\t} else {","\t\t\t// unset return value is equivalent to true","\t\t\tif(returnValue === undefined) returnValue = true;","\t\t\t","\t\t\tif(returnValue) {","\t\t\t\tif(this.saveQueue.length) {","\t\t\t\t\tthis._waitingForSave = true;","\t\t\t\t\tthis._saveItems(this.saveQueue);","\t\t\t\t\tthis.saveQueue = [];","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\tthis._debug(\"Translation successful\");","\t\t\t} else {","\t\t\t\tif(error) {","\t\t\t\t\t// report error to console","\t\t\t\t\tZotero.logError(error);","\t\t\t\t\t","\t\t\t\t\t// report error to debug log","\t\t\t\t\tthis._debug(\"Translation using \"+(this.translator && this.translator[0] && this.translator[0].label ? this.translator[0].label : \"no translator\")+\" failed: \\n\"+errorString, 2);","\t\t\t\t}","\t\t\t\t","\t\t\t\tthis._runHandler(\"error\", error);","\t\t\t}","\t\t\t","\t\t\tthis._currentState = null;","\t\t\t","\t\t\t// call handlers","\t\t\tthis._runHandler(\"itemsDone\", returnValue);","\t\t\tif(returnValue) {","\t\t\t\tthis._checkIfDone();","\t\t\t} else {","\t\t\t\tthis._runHandler(\"done\", returnValue);","\t\t\t}","\t\t}","\t\t","\t\treturn errorString;","\t},","\t","\t/**","\t * Saves items to the database, taking care to defer attachmentProgress notifications","\t * until after save","\t */","\t\"_saveItems\":function(items) {","\t\tvar me = this,","\t\t\titemDoneEventsDispatched = false,","\t\t\tdeferredProgress = [],","\t\t\tattachmentsWithProgress = [];","\t\t","\t\tthis._savingItems++;","\t\tthis._itemSaver.saveItems(items.slice(), function(returnValue, newItems) {\t","\t\t\tif(returnValue) {","\t\t\t\t// Remove attachments not being saved from item.attachments","\t\t\t\tfor(var i=0; i<items.length; i++) {","\t\t\t\t\tvar item = items[i];","\t\t\t\t\tfor(var j=0; j<item.attachments.length; j++) {","\t\t\t\t\t\tif(attachmentsWithProgress.indexOf(item.attachments[j]) === -1) {","\t\t\t\t\t\t\titem.attachments.splice(j--, 1);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t","\t\t\t\t// Trigger itemDone events","\t\t\t\tfor(var i=0, nItems = items.length; i<nItems; i++) {","\t\t\t\t\tme._runHandler(\"itemDone\", newItems[i], items[i]);","\t\t\t\t}","\t\t\t\t","\t\t\t\t// Specify that itemDone event was dispatched, so that we don't defer","\t\t\t\t// attachmentProgress notifications anymore","\t\t\t\titemDoneEventsDispatched = true;","\t\t\t\t","\t\t\t\t// Run deferred attachmentProgress notifications","\t\t\t\tfor(var i=0; i<deferredProgress.length; i++) {","\t\t\t\t\tme._runHandler(\"attachmentProgress\", deferredProgress[i][0],","\t\t\t\t\t\tdeferredProgress[i][1], deferredProgress[i][2]);","\t\t\t\t}","\t\t\t\t","\t\t\t\tme.newItems = me.newItems.concat(newItems);","\t\t\t\tme._savingItems--;","\t\t\t\tme._checkIfDone();","\t\t\t} else {","\t\t\t\tZotero.logError(newItems);","\t\t\t\tme.complete(returnValue, newItems);","\t\t\t}","\t\t},","\t\tfunction(attachment, progress, error) {","\t\t\tvar attachmentIndex = me._savingAttachments.indexOf(attachment);","\t\t\tif(progress === false || progress === 100) {","\t\t\t\tif(attachmentIndex !== -1) {","\t\t\t\t\tme._savingAttachments.splice(attachmentIndex, 1);","\t\t\t\t}","\t\t\t} else if(attachmentIndex === -1) {","\t\t\t\tme._savingAttachments.push(attachment);","\t\t\t}","\t\t\t","\t\t\tif(itemDoneEventsDispatched) {","\t\t\t\t// itemDone event has already fired, so we can fire attachmentProgress","\t\t\t\t// notifications","\t\t\t\tme._runHandler(\"attachmentProgress\", attachment, progress, error);","\t\t\t\tme._checkIfDone();","\t\t\t} else {","\t\t\t\t// Defer until after we fire the itemDone event","\t\t\t\tdeferredProgress.push([attachment, progress, error]);","\t\t\t\tattachmentsWithProgress.push(attachment);","\t\t\t}","\t\t});","\t},","\t","\t/**","\t * Checks if saving done, and if so, fires done event","\t */","\t\"_checkIfDone\":function() {","\t\tif(!this._savingItems && !this._savingAttachments.length && (!this._currentState || this._waitingForSave)) {","\t\t\tthis._runHandler(\"done\", true);","\t\t}","\t},","\t","\t/**","\t * Begins running detect code for a translator, first loading it","\t */","\t\"_detect\":function() {","\t\t// there won't be any translators if we need an RPC call","\t\tif(!this._potentialTranslators.length) {","\t\t\tthis.complete(true);","\t\t\treturn;","\t\t}","\t\t","\t\tvar me = this;","\t\tthis._loadTranslator(this._potentialTranslators[0],","\t\t\tfunction() { me._detectTranslatorLoaded() });","\t},","\t","\t/**","\t * Runs detect code for a translator","\t */","\t\"_detectTranslatorLoaded\":function() {","\t\tthis._prepareDetection();","\t\t","\t\tthis.incrementAsyncProcesses(\"Zotero.Translate#getTranslators\");","\t\t","\t\ttry {","\t\t\tvar returnValue = Function.prototype.apply.call(this._sandboxManager.sandbox[\"detect\"+this._entryFunctionSuffix], null, this._getParameters());","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn;","\t\t}","\t\t","\t\tif(returnValue !== undefined) this._returnValue = returnValue;","\t\tthis.decrementAsyncProcesses(\"Zotero.Translate#getTranslators\");","\t},","\t","\t/**","\t * Called when all translators have been collected for detection","\t */","\t\"_detectTranslatorsCollected\":function() {","\t\tZotero.debug(\"Translate: All translator detect calls and RPC calls complete\");","\t\tthis._foundTranslators.sort(function(a, b) { return a.priority-b.priority });","\t\tthis._runHandler(\"translators\", this._foundTranslators);","\t},","\t","\t/**","\t * Loads the translator into its sandbox","\t * @param {Zotero.Translator} translator","\t * @return {Boolean} Whether the translator could be successfully loaded","\t */","\t\"_loadTranslator\":function(translator, callback) {","\t\tvar sandboxLocation = this._getSandboxLocation();","\t\tif(!this._sandboxLocation || sandboxLocation !== this._sandboxLocation) {","\t\t\tthis._sandboxLocation = sandboxLocation;","\t\t\tthis._generateSandbox();","\t\t}","\t\t","\t\tthis._currentTranslator = translator;","\t\tthis._runningAsyncProcesses = 0;","\t\tthis._returnValue = undefined;","\t\tthis._aborted = false;","\t\tthis.saveQueue = [];","\t\t","\t\tZotero.debug(\"Translate: Parsing code for \"+translator.label, 4);","\t\t","\t\ttry {","\t\t\tthis._sandboxManager.eval(\"var exports = {}, ZOTERO_TRANSLATOR_INFO = \"+translator.code,","\t\t\t\t[\"detect\"+this._entryFunctionSuffix, \"do\"+this._entryFunctionSuffix, \"exports\",","\t\t\t\t\t\"ZOTERO_TRANSLATOR_INFO\"],","\t\t\t\t(translator.file ? translator.file.path : translator.label));","\t\t} catch(e) {","\t\t\tthis.complete(false, e);","\t\t\treturn;","\t\t}","\t\tthis._translatorInfo = this._sandboxManager.sandbox.ZOTERO_TRANSLATOR_INFO;","\t\t","\t\tif(callback) callback();","\t},","\t","\t/**","\t * Generates a sandbox for scraping/scraper detection","\t */","\t\"_generateSandbox\":function() {","\t\tZotero.debug(\"Translate: Binding sandbox to \"+(typeof this._sandboxLocation == \"object\" ? this._sandboxLocation.document.location : this._sandboxLocation), 4);","\t\tif (this._parentTranslator && this._parentTranslator._sandboxManager.newChild) {","\t\t\tthis._sandboxManager = this._parentTranslator._sandboxManager.newChild();","\t\t} else {","\t\t\tthis._sandboxManager = new Zotero.Translate.SandboxManager(this._sandboxLocation);","\t\t}","\t\tconst createArrays = \"['creators', 'notes', 'tags', 'seeAlso', 'attachments']\";","\t\tvar src = \"var Zotero = {};\"+","\t\t\"Zotero.Item = function (itemType) {\"+","\t\t\t\t\"const createArrays = \"+createArrays+\";\"+","\t\t\t\t\"this.itemType = itemType;\"+","\t\t\t\t\"for(var i=0, n=createArrays.length; i<n; i++) {\"+","\t\t\t\t\t\"this[createArrays[i]] = [];\"+","\t\t\t\t\"}\"+","\t\t\"};\";","\t\t","\t\tif(this instanceof Zotero.Translate.Export || this instanceof Zotero.Translate.Import) {","\t\t\tsrc += \"Zotero.Collection = function () {};\"+","\t\t\t\"Zotero.Collection.prototype.complete = function() { Zotero._collectionDone(this); };\";","\t\t}","\t\t","\t\tif(Zotero.isFx && !Zotero.isBookmarklet) {","\t\t\t// workaround for inadvertant attempts to pass E4X back from sandbox","\t\t\tsrc += \"Zotero.Item.prototype.complete = function() { \"+","\t\t\t\t\t\"for(var key in this) {\"+","\t\t\t\t\t\"if(\"+createArrays+\".indexOf(key) !== -1) {\"+","\t\t\t\t\t\t\"for each(var item in this[key]) {\"+","\t\t\t\t\t\t\t\"for(var key2 in item) {\"+","\t\t\t\t\t\t\t\t\"if(typeof item[key2] === 'xml') {\"+","\t\t\t\t\t\t\t\t\t\"item[key2] = item[key2].toString();\"+","\t\t\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\t\"}\"+","\t\t\t\t\t\"} else if(typeof this[key] === 'xml') {\"+","\t\t\t\t\t\t\"this[key] = this[key].toString();\"+","\t\t\t\t\t\"}\"+","\t\t\t\t\"}\";","\t\t} else {","\t\t\tsrc += \"Zotero.Item.prototype.complete = function() { \";","\t\t}","\t\t","\t\tsrc += \"Zotero._itemDone(this);\"+","\t\t\"}\";","","\t\tthis._sandboxManager.eval(src);","\t\tthis._sandboxManager.importObject(this.Sandbox, this);","\t\tthis._sandboxManager.importObject({\"Utilities\":new Zotero.Utilities.Translate(this)});","","\t\tthis._sandboxZotero = this._sandboxManager.sandbox.Zotero;","","\t\tif(Zotero.isFx) {","\t\t\tif(this._sandboxZotero.wrappedJSObject) this._sandboxZotero = this._sandboxZotero.wrappedJSObject;","\t\t}","\t\tthis._sandboxZotero.Utilities.HTTP = this._sandboxZotero.Utilities;","\t\t","\t\tthis._sandboxZotero.isBookmarklet = Zotero.isBookmarklet || false;","\t\tthis._sandboxZotero.isConnector = Zotero.isConnector || false;","\t\tthis._sandboxZotero.isServer = Zotero.isServer || false;","\t\tthis._sandboxZotero.parentTranslator = this._parentTranslator","\t\t\t&& this._parentTranslator._currentTranslator ? ","\t\t\tthis._parentTranslator._currentTranslator.translatorID : null;","\t\t","\t\t// create shortcuts","\t\tthis._sandboxManager.sandbox.Z = this._sandboxZotero;","\t\tthis._sandboxManager.sandbox.ZU = this._sandboxZotero.Utilities;","\t\tthis._transferItem = this._sandboxZotero._transferItem;","\t},","\t","\t/**","\t * Logs a debugging message","\t * @param {String} string Debug string to log","\t * @param {Integer} level Log level (1-5, higher numbers are higher priority)","\t */","\t\"_debug\":function(string, level) {","\t\tif(level !== undefined && typeof level !== \"number\") {","\t\t\tZotero.debug(\"debug: level must be an integer\");","\t\t\treturn;","\t\t}","\t\t","\t\t// if handler does not return anything explicitly false, show debug","\t\t// message in console","\t\tif(this._runHandler(\"debug\", string) !== false) {","\t\t\tif(typeof string == \"string\") string = \"Translate: \"+string;","\t\t\tZotero.debug(string, level);","\t\t}","\t},","\t/**","\t * Generates a string from an exception","\t * @param {String|Exception} error","\t */","\t\"_generateErrorString\":function(error) {","\t\tvar errorString = \"\";","\t\tif(typeof(error) == \"string\") {","\t\t\terrorString = \"\\nthrown exception => \"+error;","\t\t} else {","\t\t\tvar haveStack = false;","\t\t\tfor(var i in error) {","\t\t\t\tif(typeof(error[i]) != \"object\") {","\t\t\t\t\tif(i === \"stack\") haveStack = true;","\t\t\t\t\terrorString += \"\\n\"+i+' => '+error[i];","\t\t\t\t}","\t\t\t}","\t\t\terrorString += \"\\nstring => \"+error.toString();","\t\t\tif(!haveStack && error.stack) {","\t\t\t\t// In case the stack is not enumerable","\t\t\t\terrorString += \"\\nstack => \"+error.stack.toString();","\t\t\t}","\t\t}","\t\t","\t\terrorString += \"\\nurl => \"+this.path","\t\t\t+ \"\\ndownloadAssociatedFiles => \"+Zotero.Prefs.get(\"downloadAssociatedFiles\")","\t\t\t+ \"\\nautomaticSnapshots => \"+Zotero.Prefs.get(\"automaticSnapshots\");","\t\treturn errorString.substr(1);","\t},","\t","\t/**","\t * Determines the location where the sandbox should be bound","\t * @return {String|document} The location to which to bind the sandbox","\t */","\t\"_getSandboxLocation\":function() {","\t\treturn (this._parentTranslator ? this._parentTranslator._sandboxLocation : \"http://www.example.com/\");","\t},","\t","\t/**","\t * Gets parameters to be passed to detect* and do* functions","\t * @return {Array} A list of parameters","\t */","\t\"_getParameters\":function() { return []; },","\t","\t/**","\t * No-op for preparing detection","\t */","\t\"_prepareDetection\":function() {},","\t","\t/**","\t * No-op for preparing translation","\t */","\t\"_prepareTranslation\":function() {}","}","","/**"," * @class Web translation"," *"," * @property {Document} document The document object to be used for web scraping (set with setDocument)"," * @property {Zotero.CookieSandbox} cookieSandbox A CookieSandbox to manage cookies for"," *     this Translate instance."," */","Zotero.Translate.Web = function() {","\tthis._registeredDOMObservers = {}","\tthis.init();","}","Zotero.Translate.Web.prototype = new Zotero.Translate.Base();","Zotero.Translate.Web.prototype.type = \"web\";","Zotero.Translate.Web.prototype._entryFunctionSuffix = \"Web\";","Zotero.Translate.Web.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Web);","","/**"," * Sets the browser to be used for web translation"," * @param {Document} doc An HTML document"," */","Zotero.Translate.Web.prototype.setDocument = function(doc) {","\tthis.document = doc;","\tthis.setLocation(doc.location.href);","}","","/**"," * Sets a Zotero.CookieSandbox to handle cookie management for XHRs initiated from this"," * translate instance"," *"," * @param {Zotero.CookieSandbox} cookieSandbox"," */","Zotero.Translate.Web.prototype.setCookieSandbox = function(cookieSandbox) {","\tthis.cookieSandbox = cookieSandbox;","}","","/**"," * Sets the location to operate upon"," *"," * @param {String} location The URL of the page to translate"," */","Zotero.Translate.Web.prototype.setLocation = function(location) {","\tthis.location = location;","\tthis.path = this.location;","}","","/**"," * Get potential web translators"," */","Zotero.Translate.Web.prototype._getTranslatorsGetPotentialTranslators = function() {","\tvar me = this;","\tZotero.Translators.getWebTranslatorsForLocation(this.location,","\t\t\tfunction(data) {","\t\t\t\t// data[0] = list of translators","\t\t\t\t// data[1] = list of functions to convert proper URIs to proxied URIs","\t\t\t\tme._getTranslatorsTranslatorsReceived(data[0], data[1]);","\t\t\t});","}","","/**"," * Bind sandbox to document being translated"," */","Zotero.Translate.Web.prototype._getSandboxLocation = function() {","\tif(this._parentTranslator) {","\t\treturn this._parentTranslator._sandboxLocation;","\t} else if(this.document.defaultView","\t\t\t&& (this.document.defaultView.toString().indexOf(\"Window\") !== -1","\t\t\t\t|| this.document.defaultView.toString().indexOf(\"XrayWrapper\") !== -1)) {","\t\treturn this.document.defaultView;","\t} else {","\t\treturn this.document.location.toString();","\t}","}","","/**"," * Pass document and location to detect* and do* functions"," */","Zotero.Translate.Web.prototype._getParameters = function() {","\tif (Zotero.Translate.DOMWrapper &&","\t\tZotero.Translate.DOMWrapper.isWrapped(this.document) &&","\t\tZotero.platformMajorVersion >= 35) {","\t\treturn [this._sandboxManager.wrap(Zotero.Translate.DOMWrapper.unwrap(this.document), null,","\t\t\t                              this.document.__wrapperOverrides), this.location];","\t} else {","\t\treturn [this.document, this.location];","\t}","};","","/**"," * Prepare translation"," */","Zotero.Translate.Web.prototype._prepareTranslation = function() {","\tthis._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,","\t\tZotero.Translate.ItemSaver[(this._saveAttachments ? \"ATTACHMENT_MODE_DOWNLOAD\" : \"ATTACHMENT_MODE_IGNORE\")], 1,","\t\tthis.document, this._cookieSandbox, this.location);","\tthis.newItems = [];","}","","/**"," * Overload translate to set selectedItems"," */","Zotero.Translate.Web.prototype.translate = function(libraryID, saveAttachments, selectedItems) {","\tthis._selectedItems = selectedItems;","\tZotero.Translate.Base.prototype.translate.apply(this, [libraryID, saveAttachments]);","}","","/**"," * Overload _translateTranslatorLoaded to send an RPC call if necessary"," */","Zotero.Translate.Web.prototype._translateTranslatorLoaded = function() {","\tvar runMode = this.translator[0].runMode;","\tif(runMode === Zotero.Translator.RUN_MODE_IN_BROWSER || this._parentTranslator) {","\t\tZotero.Translate.Base.prototype._translateTranslatorLoaded.apply(this);","\t} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE ||","\t\t\t(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER && Zotero.Connector.isOnline)) {","\t\tvar me = this;","\t\tZotero.Connector.callMethod(\"savePage\", {","\t\t\t\t\"uri\":this.location.toString(),","\t\t\t\t\"translatorID\":(typeof this.translator[0] === \"object\"","\t\t\t\t                ? this.translator[0].translatorID : this.translator[0]),","\t\t\t\t\"cookie\":this.document.cookie,","\t\t\t\t\"html\":this.document.documentElement.innerHTML","\t\t\t}, function(obj) { me._translateRPCComplete(obj) });","\t} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER) {","\t\tvar me = this;","\t\tZotero.API.createItem({\"url\":this.document.location.href.toString()},","\t\t\tfunction(statusCode, response) {","\t\t\t\tme._translateServerComplete(statusCode, response);","\t\t\t});","\t}","}","\t","/**"," * Called when an call to Zotero Standalone for translation completes"," */","Zotero.Translate.Web.prototype._translateRPCComplete = function(obj, failureCode) {","\tif(!obj) this.complete(false, failureCode);","\t","\tif(obj.selectItems) {","\t\t// if we have to select items, call the selectItems handler and do it","\t\tvar me = this;","\t\tthis._runHandler(\"select\", obj.selectItems,","\t\t\tfunction(selectedItems) {","\t\t\t\tZotero.Connector.callMethod(\"selectItems\",","\t\t\t\t\t{\"instanceID\":obj.instanceID, \"selectedItems\":selectedItems},","\t\t\t\t\tfunction(obj) { me._translateRPCComplete(obj) })","\t\t\t}","\t\t);","\t} else {","\t\t// if we don't have to select items, continue","\t\tfor(var i=0, n=obj.items.length; i<n; i++) {","\t\t\tthis._runHandler(\"itemDone\", null, obj.items[i]);","\t\t}","\t\tthis.newItems = obj.items;","\t\tthis.complete(true);","\t}","}","\t","/**"," * Called when an call to the Zotero Translator Server for translation completes"," */","Zotero.Translate.Web.prototype._translateServerComplete = function(statusCode, response) {","\tif(statusCode === 300) {","\t\t// Multiple Choices","\t\ttry {","\t\t\tresponse = JSON.parse(response);","\t\t} catch(e) {","\t\t\tZotero.logError(e);","\t\t\tthis.complete(false, \"Invalid JSON response received from server\");","\t\t\treturn;","\t\t}","\t\tvar me = this;","\t\tthis._runHandler(\"select\", response,","\t\t\tfunction(selectedItems) {","\t\t\t\tZotero.API.createItem({","\t\t\t\t\t\t\"url\":me.document.location.href.toString(),","\t\t\t\t\t\t\"items\":selectedItems","\t\t\t\t\t},","\t\t\t\t\tfunction(statusCode, response) {","\t\t\t\t\t\t\tme._translateServerComplete(statusCode, response);","\t\t\t\t\t});","\t\t\t}","\t\t);","\t} else if(statusCode === 201) {","\t\t// Created","\t\ttry {","\t\t\tresponse = (new DOMParser()).parseFromString(response, \"application/xml\");","\t\t} catch(e) {","\t\t\tZotero.logError(e);","\t\t\tthis.complete(false, \"Invalid XML response received from server\");","\t\t\treturn;","\t\t}","\t\t","\t\t// Extract items from ATOM/JSON response","\t\tvar items = [], contents;","\t\tif(\"getElementsByTagNameNS\" in response) {","\t\t\tcontents = response.getElementsByTagNameNS(\"http://www.w3.org/2005/Atom\", \"content\");","\t\t} else { // IE...","\t\t\tcontents = response.getElementsByTagName(\"content\");","\t\t}","\t\tfor(var i=0, n=contents.length; i<n; i++) {","\t\t\tvar content = contents[i];","\t\t\tif(\"getAttributeNS\" in content) {","\t\t\t\tif(content.getAttributeNS(\"http://zotero.org/ns/api\", \"type\") != \"json\") continue;","\t\t\t} else if(content.getAttribute(\"zapi:type\") != \"json\") { // IE...","\t\t\t\tcontinue;","\t\t\t}","\t\t\t","\t\t\ttry {","\t\t\t\tvar item = JSON.parse(\"textContent\" in content ?","\t\t\t\t\tcontent.textContent : content.text);","\t\t\t} catch(e) {","\t\t\t\tZotero.logError(e);","\t\t\t\tthis.complete(false, \"Invalid JSON response received from server\");","\t\t\t\treturn;","\t\t\t}","\t\t\t","\t\t\tif(!(\"attachments\" in item)) item.attachments = [];","\t\t\tthis._runHandler(\"itemDone\", null, item);","\t\t\titems.push(item);","\t\t}","\t\tthis.newItems = items;","\t\tthis.complete(true);","\t} else {","\t\tthis.complete(false, response);","\t}","}","","/**"," * Overload complete to report translation failure"," */","Zotero.Translate.Web.prototype.complete = function(returnValue, error) {","\t// call super","\tvar oldState = this._currentState;","\tvar errorString = Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","\t","\t// Report translation failure if we failed","\tif(oldState == \"translate\" && errorString && !this._parentTranslator && this.translator.length","\t\t&& this.translator[0].inRepository && Zotero.Prefs.get(\"reportTranslationFailure\")) {","\t\t// Don't report failure if in private browsing mode","\t\tif(Zotero.isFx && !Zotero.isBookmarklet && !Zotero.isStandalone && Components.classes[\"@mozilla.org/privatebrowsing;1\"]) {","\t\t\tvar pbs = Components.classes[\"@mozilla.org/privatebrowsing;1\"]","\t\t\t\t\t\t.getService(Components.interfaces.nsIPrivateBrowsingService);","\t\t\tif (pbs.privateBrowsingEnabled) {","\t\t\t\treturn;","\t\t\t}","\t\t}","\t\t","\t\tvar translator = this.translator[0];","\t\tZotero.getSystemInfo(function(info) {","\t\t\tvar postBody = \"id=\" + encodeURIComponent(translator.translatorID) +","\t\t\t\t\t\t   \"&lastUpdated=\" + encodeURIComponent(translator.lastUpdated) +","\t\t\t\t\t\t   \"&diagnostic=\" + encodeURIComponent(info) +","\t\t\t\t\t\t   \"&errorData=\" + encodeURIComponent(errorString);","\t\t\tZotero.HTTP.doPost(ZOTERO_CONFIG.REPOSITORY_URL + \"report\", postBody);","\t\t});","\t}","}","","/**"," * @class Import translation"," */","Zotero.Translate.Import = function() {","\tthis.init();","}","Zotero.Translate.Import.prototype = new Zotero.Translate.Base();","Zotero.Translate.Import.prototype.type = \"import\";","Zotero.Translate.Import.prototype._entryFunctionSuffix = \"Import\";","Zotero.Translate.Import.prototype._io = false;","","Zotero.Translate.Import.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Import);","","/**"," * Sets string for translation and initializes string IO"," */","Zotero.Translate.Import.prototype.setString = function(string) {","\tthis._string = string;","\tthis._io = false;","}","","/**"," * Overload {@link Zotero.Translate.Base#complete} to close file"," */","Zotero.Translate.Import.prototype.complete = function(returnValue, error) {","\tif(this._io) {","\t\tthis._progress = null;","\t\tthis._io.close(false);","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Get all potential import translators, ordering translators with the right file extension first"," */","Zotero.Translate.Import.prototype._getTranslatorsGetPotentialTranslators = function() {","\tif(this.location) {","\t\tvar me = this;","\t\tZotero.Translators.getImportTranslatorsForLocation(this.location,","\t\t\tfunction(translators) { me._getTranslatorsTranslatorsReceived(translators) });","\t} else {","\t\tZotero.Translate.Base.prototype._getTranslatorsGetPotentialTranslators.call(this);","\t}","}","","/**"," * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately only"," * if no string or location is set"," */","Zotero.Translate.Import.prototype.getTranslators = function() {","\tif(!this._string && !this.location) {","\t\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\t\tthis._currentState = \"detect\";","\t\tvar me = this;","\t\tZotero.Translators.getAllForType(this.type, function(translators) {","\t\t\tme._potentialTranslators = [];","\t\t\tme._foundTranslators = translators;","\t\t\tme.complete(true);","\t\t});","\t\tif(this._currentState === null) return this._foundTranslators;","\t} else {","\t\treturn Zotero.Translate.Base.prototype.getTranslators.call(this);","\t}","}","\t","/**"," * Overload {@link Zotero.Translate.Base#_loadTranslator} to prepare translator IO"," */","Zotero.Translate.Import.prototype._loadTranslator = function(translator, callback) {","\t// call super","\tvar me = this;","\tZotero.Translate.Base.prototype._loadTranslator.call(this, translator, function() {","\t\tme._loadTranslatorPrepareIO(translator, callback);","\t});","}","\t","/**"," * Prepare translator IO"," */","Zotero.Translate.Import.prototype._loadTranslatorPrepareIO = function(translator, callback) {","\tvar configOptions = this._translatorInfo.configOptions;","\tvar dataMode = configOptions ? configOptions[\"dataMode\"] : \"\";","\t","\tvar me = this;","\tvar initCallback = function(status, err) {","\t\tif(!status) {","\t\t\tme.complete(false, err);","\t\t} else {","\t\t\tme._sandboxManager.importObject(me._io);","\t\t\tif(callback) callback();","\t\t}","\t};","\t","\tvar err = false;","\tif(!this._io) {","\t\tif(Zotero.Translate.IO.Read && this.location && this.location instanceof Components.interfaces.nsIFile) {","\t\t\ttry {","\t\t\t\tthis._io = new Zotero.Translate.IO.Read(this.location, this._sandboxManager);","\t\t\t} catch(e) {","\t\t\t\terr = e;","\t\t\t}","\t\t} else {","\t\t\ttry {","\t\t\t\tthis._io = new Zotero.Translate.IO.String(this._string, this.path ? this.path : \"\", this._sandboxManager);","\t\t\t} catch(e) {","\t\t\t\terr = e;","\t\t\t}","\t\t}","\t","\t\tif(err) {","\t\t\tthis.complete(false, err);","\t\t\treturn;","\t\t}","\t}","\t","\ttry {","\t\tthis._io.init(dataMode, initCallback);","\t} catch(e) {","\t\terr = e;","\t}","\tif(err) {","\t\tthis.complete(false, err);","\t\treturn;","\t}","}","","/**"," * Prepare translation"," */","Zotero.Translate.Import.prototype._prepareTranslation = function() {","\tthis._progress = undefined;","\t","\tvar baseURI = null;","\tif(this.location) {","\t\ttry {","\t\t\tbaseURI = Components.classes[\"@mozilla.org/network/io-service;1\"].","\t\t\t\tgetService(Components.interfaces.nsIIOService).newFileURI(this.location);","\t\t} catch(e) {}","\t}","\t","\tthis._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,","\t\tZotero.Translate.ItemSaver[(this._saveAttachments ? \"ATTACHMENT_MODE_FILE\" : \"ATTACHMENT_MODE_IGNORE\")],","\t\tundefined, undefined, undefined, baseURI);","\tthis.newItems = [];","\tthis.newCollections = [];","}","","/**"," * Return the progress of the import operation, or null if progress cannot be determined"," */","Zotero.Translate.Import.prototype.getProgress = function() {","\tif(this._progress !== undefined) return this._progress;","\tif(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 || this._mode === \"xml/e4x\" || this._mode == \"xml/dom\" || !this._io) {","\t\treturn null;","\t}","\treturn this._io.bytesRead/this._io.contentLength*100;","};","\t","","/**"," * @class Export translation"," */","Zotero.Translate.Export = function() {","\tthis.init();","}","Zotero.Translate.Export.prototype = new Zotero.Translate.Base();","Zotero.Translate.Export.prototype.type = \"export\";","Zotero.Translate.Export.prototype._entryFunctionSuffix = \"Export\";","Zotero.Translate.Export.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Export);","","/**"," * Sets the items to be exported"," * @param {Zotero.Item[]} items"," */","Zotero.Translate.Export.prototype.setItems = function(items) {","\tthis._items = items;","\tdelete this._collection;","}","","/**"," * Sets the collection to be exported (overrides setItems)"," * @param {Zotero.Collection[]} collection"," */","Zotero.Translate.Export.prototype.setCollection = function(collection) {","\tthis._collection = collection;","\tdelete this._items;","}","","/**"," * Sets the translator to be used for export"," *"," * @param {Zotero.Translator|string} Translator object or ID. If this contains a displayOptions"," *    attribute, setDisplayOptions is automatically called with the specified value."," */","Zotero.Translate.Export.prototype.setTranslator = function(translator) {","\tif(typeof translator == \"object\" && translator.displayOptions) {","\t\tthis._displayOptions = translator.displayOptions;","\t}","\treturn Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);","}","","/**"," * Sets translator display options. you can also pass a translator (not ID) to"," * setTranslator that includes a displayOptions argument"," */","Zotero.Translate.Export.prototype.setDisplayOptions = function(displayOptions) {","\tthis._displayOptions = displayOptions;","}","","/**"," * Overload {@link Zotero.Translate.Base#complete} to close file and set complete"," */","Zotero.Translate.Export.prototype.complete = function(returnValue, error) {","\tif(this._io) {","\t\tthis._progress = null;","\t\tthis._io.close(true);","\t\tif(this._io instanceof Zotero.Translate.IO.String) {","\t\t\tthis.string = this._io.string;","\t\t}","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately"," */","Zotero.Translate.Export.prototype.getTranslators = function() {","\tif(this._currentState === \"detect\") throw new Error(\"getTranslators: detection is already running\");","\tthis._currentState = \"detect\";","\tthis._foundTranslators = Zotero.Translators.getAllForType(this.type);","\tthis._potentialTranslators = [];","\tthis.complete(true);","\treturn this._foundTranslators;","}","","/**"," * Does the actual export, after code has been loaded and parsed"," */","Zotero.Translate.Export.prototype._prepareTranslation = function() {","\tthis._progress = undefined;","\t","\t// initialize ItemGetter","\tthis._itemGetter = new Zotero.Translate.ItemGetter();","\tvar configOptions = this._translatorInfo.configOptions || {},","\t\tgetCollections = configOptions.getCollections || false;","\tif(this._collection) {","\t\tthis._itemGetter.setCollection(this._collection, getCollections);","\t\tdelete this._collection;","\t} else if(this._items) {","\t\tthis._itemGetter.setItems(this._items);","\t\tdelete this._items;","\t} else {","\t\tthis._itemGetter.setAll(getCollections);","\t}","\t","\t// export file data, if requested","\tif(this._displayOptions[\"exportFileData\"]) {","\t\tthis.location = this._itemGetter.exportFiles(this.location, this.translator[0].target);","\t}","\t","\t// initialize IO","\t// this is currently hackish since we pass null callbacks to the init function (they have","\t// callbacks to be consistent with import, but they are synchronous, so we ignore them)","\tif(!this.location) {","\t\tthis._io = new Zotero.Translate.IO.String(null, this.path ? this.path : \"\", this._sandboxManager);","\t\tthis._io.init(configOptions[\"dataMode\"], function() {});","\t} else if(!Zotero.Translate.IO.Write) {","\t\tthrow new Error(\"Writing to files is not supported in this build of Zotero.\");","\t} else {","\t\tthis._io = new Zotero.Translate.IO.Write(this.location);","\t\tthis._io.init(configOptions[\"dataMode\"],","\t\t\tthis._displayOptions[\"exportCharset\"] ? this._displayOptions[\"exportCharset\"] : null,","\t\t\tfunction() {});","\t}","\t","\tthis._sandboxManager.importObject(this._io);","}","","/**"," * Overload Zotero.Translate.Base#translate to make sure that"," *   Zotero.Translate.Export#translate is not called without setting a"," *   translator first. Doesn't make sense to run detection for export."," */","Zotero.Translate.Export.prototype.translate = function() {","\tif(!this.translator || !this.translator.length) {","\t\tthis.complete(false, new Error(\"Export translation initiated without setting a translator\"));","\t} else {","\t\tZotero.Translate.Base.prototype.translate.apply(this, arguments);","\t}","};","","/**"," * Return the progress of the import operation, or null if progress cannot be determined"," */","Zotero.Translate.Export.prototype.getProgress = function() {","\tif(this._progress !== undefined) return this._progress;","\tif(!this._itemGetter) {","\t\treturn null;","\t}","\treturn (1-this._itemGetter.numItemsRemaining/this._itemGetter.numItems)*100;","};","","/**"," * @class Search translation"," * @property {Array[]} search Item (in {@link Zotero.Item#serialize} format) to extrapolate data"," *    (set with setSearch)"," */","Zotero.Translate.Search = function() {","\tthis.init();","};","Zotero.Translate.Search.prototype = new Zotero.Translate.Base();","Zotero.Translate.Search.prototype.type = \"search\";","Zotero.Translate.Search.prototype._entryFunctionSuffix = \"Search\";","Zotero.Translate.Search.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Search);","","/**"," * @borrows Zotero.Translate.Web#setCookieSandbox"," */","Zotero.Translate.Search.prototype.setCookieSandbox = Zotero.Translate.Web.prototype.setCookieSandbox;","","/**"," * Sets the item to be used for searching"," * @param {Object} item An item, with as many fields as desired, in the format returned by"," *     {@link Zotero.Item#serialize}"," */","Zotero.Translate.Search.prototype.setSearch = function(search) {","\tthis.search = search;","}","","/**"," * Overloads {@link Zotero.Translate.Base#getTranslators} to always return all potential translators"," */","Zotero.Translate.Search.prototype.getTranslators = function() {","\treturn Zotero.Translate.Base.prototype.getTranslators.call(this, true);","}","","/**"," * Sets the translator or translators to be used for search"," *"," * @param {Zotero.Translator|string} Translator object or ID"," */","Zotero.Translate.Search.prototype.setTranslator = function(translator) {","\tif(typeof translator == \"object\" && !translator.translatorID) {","\t\t// we have an array of translators","\t\t","\t\t// accept a list of objects","\t\tthis.translator = [];","\t\tfor(var i=0, n=translator.length; i<n; i++) {","\t\t\tthis.translator.push(translator[i]);","\t\t}","\t\treturn true;","\t} else {","\t\treturn Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);","\t}","}","","/**"," * Overload Zotero.Translate.Base#complete to move onto the next translator if"," * translation fails"," */","Zotero.Translate.Search.prototype.complete = function(returnValue, error) {","\tif(this._currentState == \"translate\" && (!this.newItems || !this.newItems.length)","\t\t&& this.translator.length) { //length is 0 only when translate was called without translators","\t\tZotero.debug(\"Translate: Could not find a result using \"+this.translator[0].label, 3);","\t\tif(error) Zotero.debug(this._generateErrorString(error), 3);","\t\tif(this.translator.length > 1) {","\t\t\tthis.translator.shift();","\t\t\tthis.translate(this._libraryID, this._saveAttachments);","\t\t\treturn;","\t\t} else {","\t\t\terror = \"No items returned from any translator\";","\t\t\treturnValue = false;","\t\t}","\t}","\t","\t// call super","\tZotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);","}","","/**"," * Pass search item to detect* and do* functions"," */","Zotero.Translate.Search.prototype._getParameters = function() {","\tif(Zotero.isFx) {","\t\treturn [this._sandboxManager.copyObject(this.search)];","\t}","\treturn [this.search];","};","","/**"," * Extract sandbox location from translator target"," */","Zotero.Translate.Search.prototype._getSandboxLocation = function() {","\t// generate sandbox for search by extracting domain from translator target","\tif(this.translator && this.translator[0] && this.translator[0].target) {","\t\t// so that web translators work too","\t\tconst searchSandboxRe = /^http:\\/\\/[\\w.]+\\//;","\t\tvar tempURL = this.translator[0].target.replace(/\\\\/g, \"\").replace(/\\^/g, \"\");","\t\tvar m = searchSandboxRe.exec(tempURL);","\t\tif(m) return m[0];","\t}","\treturn Zotero.Translate.Base.prototype._getSandboxLocation.call(this);","}","","Zotero.Translate.Search.prototype._prepareTranslation = Zotero.Translate.Web.prototype._prepareTranslation;","","/**"," * IO-related functions"," * @namespace"," */","Zotero.Translate.IO = {","\t/**","\t * Parses XML using DOMParser","\t */","\t\"parseDOMXML\":function(input, charset, size) {","\t\ttry {","\t\t\tvar dp = new DOMParser();","\t\t} catch(e) {","\t\t\ttry {","\t\t\t\tvar dp = Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]","\t\t\t\t   .createInstance(Components.interfaces.nsIDOMParser);","\t\t\t} catch(e) {","\t\t\t\tthrow new Error(\"DOMParser not supported\");","\t\t\t}","\t\t}","\t\t","\t\tif(typeof input == \"string\") {","\t\t\tvar nodes = dp.parseFromString(input, \"text/xml\");","\t\t} else {","\t\t\tvar nodes = dp.parseFromStream(input, charset, size, \"text/xml\");","\t\t}","\t\t","\t\tif(nodes.getElementsByTagName(\"parsererror\").length) {","\t\t\tthrow \"DOMParser error: loading data into data store failed\";","\t\t}","\t\t","\t\tif(\"normalize\" in nodes) nodes.normalize();","\t\t","\t\treturn nodes;","\t},","\t","\t/**","\t * Names of RDF data modes","\t */","\t\"rdfDataModes\":[\"rdf\", \"rdf/xml\", \"rdf/n3\"]","};","","/******* String support *******/","","/**"," * @class Translate backend for translating from a string"," */","Zotero.Translate.IO.String = function(string, uri, sandboxManager) {","\tif(string && typeof string === \"string\") {","\t\tthis.string = string;","\t} else {","\t\tthis.string = \"\";","\t}","\tthis.contentLength = this.string.length;","\tthis.bytesRead = 0;","\tthis._uri = uri;","\tthis._sandboxManager = sandboxManager;","}","","Zotero.Translate.IO.String.prototype = {","\t\"__exposedProps__\":{","\t\t\"RDF\":\"r\",","\t\t\"read\":\"r\",","\t\t\"write\":\"r\",","\t\t\"setCharacterSet\":\"r\",","\t\t\"getXML\":\"r\"","\t},","\t","\t\"_initRDF\":function(callback) {","\t\tZotero.debug(\"Translate: Initializing RDF data store\");","\t\tthis._dataStore = new Zotero.RDF.AJAW.IndexedFormula();","\t\tthis.RDF = new Zotero.Translate.IO._RDFSandbox(this._dataStore);","\t\t","\t\tif(this.contentLength) {","\t\t\ttry {","\t\t\t\tvar xml = Zotero.Translate.IO.parseDOMXML(this.string);","\t\t\t} catch(e) {","\t\t\t\tthis._xmlInvalid = true;","\t\t\t\tthrow e;","\t\t\t}","\t\t\tvar parser = new Zotero.RDF.AJAW.RDFParser(this._dataStore);","\t\t\tparser.parse(xml, this._uri);","\t\t}","\t\tcallback(true);","\t},","\t","\t\"setCharacterSet\":function(charset) {},","\t","\t\"read\":function(bytes) {","\t\t// if we are reading in RDF data mode and no string is set, serialize current RDF to the","\t\t// string","\t\tif(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === \"\") {","\t\t\tthis.string = this.RDF.serialize();","\t\t}","\t\t","\t\t// return false if string has been read","\t\tif(this.bytesRead >= this.contentLength) {","\t\t\treturn false;","\t\t}","\t\t","\t\tif(bytes !== undefined) {","\t\t\tif(this.bytesRead >= this.contentLength) return false;","\t\t\tvar oldPointer = this.bytesRead;","\t\t\tthis.bytesRead += bytes;","\t\t\treturn this.string.substr(oldPointer, bytes);","\t\t} else {","\t\t\t// bytes not specified; read a line","\t\t\tvar oldPointer = this.bytesRead;","\t\t\tvar lfIndex = this.string.indexOf(\"\\n\", this.bytesRead);","\t\t\t","\t\t\tif(lfIndex !== -1) {","\t\t\t\t// in case we have a CRLF","\t\t\t\tthis.bytesRead = lfIndex+1;","\t\t\t\tif(this.contentLength > lfIndex && this.string.substr(lfIndex-1, 1) === \"\\r\") {","\t\t\t\t\tlfIndex--;","\t\t\t\t}","\t\t\t\treturn this.string.substr(oldPointer, lfIndex-oldPointer);\t\t\t\t\t","\t\t\t}","\t\t\t","\t\t\tif(!this._noCR) {","\t\t\t\tvar crIndex = this.string.indexOf(\"\\r\", this.bytesRead);","\t\t\t\tif(crIndex === -1) {","\t\t\t\t\tthis._noCR = true;","\t\t\t\t} else {","\t\t\t\t\tthis.bytesRead = crIndex+1;","\t\t\t\t\treturn this.string.substr(oldPointer, crIndex-oldPointer-1);","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\tthis.bytesRead = this.contentLength;","\t\t\treturn this.string.substr(oldPointer);","\t\t}","\t},","\t","\t\"write\":function(data) {","\t\tthis.string += data;","\t\tthis.contentLength = this.string.length;","\t},","\t","\t\"getXML\":function() {","\t\ttry {","\t\t\tvar xml = Zotero.Translate.IO.parseDOMXML(this.string);","\t\t} catch(e) {","\t\t\tthis._xmlInvalid = true;","\t\t\tthrow e;","\t\t}","\t\treturn (Zotero.isFx && !Zotero.isBookmarklet ? this._sandboxManager.wrap(xml) : xml);","\t},","\t","\t\"init\":function(newMode, callback) {","\t\tthis.bytesRead = 0;","\t\tthis._noCR = undefined;","\t\t","\t\tthis._mode = newMode;","\t\tif(newMode === \"xml/e4x\") {","\t\t\tthrow \"E4X is not supported\";","\t\t} else if(newMode && (Zotero.Translate.IO.rdfDataModes.indexOf(newMode) !== -1","\t\t\t\t|| newMode.substr(0, 3) === \"xml/dom\") && this._xmlInvalid) {","\t\t\tthrow \"XML known invalid\";","\t\t} else if(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1) {","\t\t\tthis._initRDF(callback);","\t\t} else {","\t\t\tcallback(true);","\t\t}","\t},","\t","\t\"close\":function(serialize) {","\t\t// if we are writing in RDF data mode and no string is set, serialize current RDF to the","\t\t// string","\t\tif(serialize && Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === \"\") {","\t\t\tthis.string = this.RDF.serialize();","\t\t}","\t}","}","","/****** RDF DATA MODE ******/","","/**"," * @class An API for handling RDF from the sandbox. This is exposed to translators as Zotero.RDF."," *"," * @property {Zotero.RDF.AJAW.IndexedFormula} _dataStore"," * @property {Integer[]} _containerCounts"," * @param {Zotero.RDF.AJAW.IndexedFormula} dataStore"," */","Zotero.Translate.IO._RDFSandbox = function(dataStore) {","\tthis._dataStore = dataStore;","}","","Zotero.Translate.IO._RDFSandbox.prototype = {","\t\"_containerCounts\":[],","\t\"__exposedProps__\":{","\t\t\"addStatement\":\"r\",","\t\t\"newResource\":\"r\",","\t\t\"newContainer\":\"r\",","\t\t\"addContainerElement\":\"r\",","\t\t\"getContainerElements\":\"r\",","\t\t\"addNamespace\":\"r\",","\t\t\"getAllResources\":\"r\",","\t\t\"getResourceURI\":\"r\",","\t\t\"getArcsIn\":\"r\",","\t\t\"getArcsOut\":\"r\",","\t\t\"getSources\":\"r\",","\t\t\"getTargets\":\"r\",","\t\t\"getStatementsMatching\":\"r\",","\t\t\"serialize\":\"r\"","\t},","\t","\t/**","\t * Gets a resource as a Zotero.RDF.AJAW.Symbol, rather than a string","\t * @param {String|Zotero.RDF.AJAW.Symbol} about","\t * @return {Zotero.RDF.AJAW.Symbol}","\t */","\t\"_getResource\":function(about) {","\t\treturn (typeof about == \"object\" ? about : new Zotero.RDF.AJAW.Symbol(about));","\t},","\t","\t/**","\t * Runs a callback to initialize this RDF store","\t */","\t\"_init\":function() {","\t\tif(this._prepFunction) {","\t\t\tthis._dataStore = this._prepFunction();","\t\t\tdelete this._prepFunction;","\t\t}","\t},","\t","\t/**","\t * Serializes the current RDF to a string","\t */","\t\"serialize\":function(dataMode) {","\t\tvar serializer = Zotero.RDF.AJAW.Serializer(this._dataStore);","\t\t","\t\tfor(var prefix in this._dataStore.namespaces) {","\t\t\tserializer.suggestPrefix(prefix, this._dataStore.namespaces[prefix]);","\t\t}","\t\t","\t\t// serialize in appropriate format","\t\tif(dataMode == \"rdf/n3\") {","\t\t\treturn serializer.statementsToN3(this._dataStore.statements);","\t\t}","\t\t","\t\treturn serializer.statementsToXML(this._dataStore.statements);","\t},","\t","\t/**","\t * Adds an RDF triple","\t * @param {String|Zotero.RDF.AJAW.Symbol} about","\t * @param {String|Zotero.RDF.AJAW.Symbol} relation","\t * @param {String|Zotero.RDF.AJAW.Symbol} value","\t * @param {Boolean} literal Whether value should be treated as a literal (true) or a resource","\t *     (false)","\t */","\t\"addStatement\":function(about, relation, value, literal) {","\t\tif(about === null || about === undefined) {","\t\t\tthrow new Error(\"about must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\tif(relation === null || relation === undefined) {","\t\t\tthrow new Error(\"relation must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\tif(value === null || value === undefined) {","\t\t\tthrow new Error(\"value must be defined in Zotero.RDF.addStatement\");","\t\t}","\t\t","\t\tif(literal) {","\t\t\t// zap chars that Mozilla will mangle","\t\t\tvalue = value.toString().replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g, '');","\t\t} else {","\t\t\tvalue = this._getResource(value);","\t\t}","\t\t","\t\tthis._dataStore.add(this._getResource(about), this._getResource(relation), value);","\t},","\t","\t/**","\t * Creates a new anonymous resource","\t * @return {Zotero.RDF.AJAW.Symbol}","\t */","\t\"newResource\":function() {","\t\treturn new Zotero.RDF.AJAW.BlankNode();","\t},","\t","\t/**","\t * Creates a new container resource","\t * @param {String} type The type of the container (\"bag\", \"seq\", or \"alt\")","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The URI of the resource","\t * @return {Zotero.Translate.RDF.prototype.newContainer","\t */","\t\"newContainer\":function(type, about) {","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t\tconst containerTypes = {\"bag\":\"Bag\", \"seq\":\"Seq\", \"alt\":\"Alt\"};","\t\t","\t\ttype = type.toLowerCase();","\t\tif(!containerTypes[type]) {","\t\t\tthrow new Error(\"Invalid container type in Zotero.RDF.newContainer\");","\t\t}","\t\t","\t\tvar about = this._getResource(about);","\t\tthis.addStatement(about, rdf+\"type\", rdf+containerTypes[type], false);","\t\tthis._containerCounts[about.toNT()] = 1;","\t\t","\t\treturn about;","\t},","\t","\t/**","\t * Adds a new element to a container","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The container","\t * @param {String|Zotero.RDF.AJAW.Symbol} element The element to add to the container","\t * @param {Boolean} literal Whether element should be treated as a literal (true) or a resource","\t *     (false)","\t */","\t\"addContainerElement\":function(about, element, literal) {","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t","\t\tvar about = this._getResource(about);","\t\tthis._dataStore.add(about, new Zotero.RDF.AJAW.Symbol(rdf+\"_\"+(this._containerCounts[about.toNT()]++)), element, literal);","\t},","\t","\t/**","\t * Gets all elements within a container","\t * @param {String|Zotero.RDF.AJAW.Symbol} about The container","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t */","\t\"getContainerElements\":function(about) {","\t\tconst liPrefix = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#_\";","\t\t","\t\tvar about = this._getResource(about);","\t\tvar statements = this._dataStore.statementsMatching(about);","\t\tvar containerElements = [];","\t\t","\t\t// loop over arcs out looking for list items","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\tvar statement = statements[i];","\t\t\tif(statement.predicate.uri.substr(0, liPrefix.length) == liPrefix) {","\t\t\t\tvar number = statement.predicate.uri.substr(liPrefix.length);","\t\t\t\t","\t\t\t\t// make sure these are actually numeric list items","\t\t\t\tvar intNumber = parseInt(number);","\t\t\t\tif(number == intNumber.toString()) {","\t\t\t\t\t// add to element array","\t\t\t\t\tcontainerElements[intNumber-1] = (statement.object.termType == \"literal\" ? statement.object.toString() : statement.object);","\t\t\t\t}","\t\t\t}","\t\t}","\t\t","\t\treturn containerElements;","\t},","\t","\t/**","\t * Adds a namespace for a specific URI","\t * @param {String} prefix Namespace prefix","\t * @param {String} uri Namespace URI","\t */","\t\"addNamespace\":function(prefix, uri) {","\t\tthis._dataStore.setPrefixForURI(prefix, uri);","\t},","\t","\t/**","\t * Gets the URI a specific resource","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource","\t * @return {String}","\t */","\t\"getResourceURI\":function(resource) {","\t\tif(typeof(resource) == \"string\") return resource;","\t\t","\t\tconst rdf = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";","\t\tvar values = this.getTargets(resource, rdf + 'value');","\t\tif(values && values.length) return this.getResourceURI(values[0]);","\t\t","\t\tif(resource.uri) return resource.uri;","\t\tif(resource.toNT == undefined) throw new Error(\"Zotero.RDF: getResourceURI called on invalid resource\");","\t\treturn resource.toNT();","\t},","\t","\t/**","\t * Gets all resources in the RDF data store","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t */","\t\"getAllResources\":function() {","\t\tvar returnArray = [];","\t\tfor(var i in this._dataStore.subjectIndex) {","\t\t\treturnArray.push(this._dataStore.subjectIndex[i][0].subject);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all arcs (predicates) into a resource","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getArcsIn\":function(resource) {","\t\tvar statements = this._dataStore.objectIndex[this._dataStore.canon(this._getResource(resource))];","\t\tif(!statements) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].predicate.uri);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all arcs (predicates) out of a resource","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getArcsOut\":function(resource) {","\t\tvar statements = this._dataStore.subjectIndex[this._dataStore.canon(this._getResource(resource))];","\t\tif(!statements) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].predicate.uri);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all subjects whose predicates point to a resource","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject that predicates should point to","\t * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getSources\":function(resource, property) {","\t\tvar statements = this._dataStore.statementsMatching(undefined, this._getResource(property), this._getResource(resource));","\t\tif(!statements.length) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].subject);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets all objects of a given subject with a given predicate","\t * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject","\t * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate","\t * @return {Zotero.RDF.AJAW.Symbol[]}","\t * @deprecated Since 2.1. Use {@link Zotero.Translate.IO[\"rdf\"]._RDFBase#getStatementsMatching}","\t */","\t\"getTargets\":function(resource, property) {","\t\tvar statements = this._dataStore.statementsMatching(this._getResource(resource), this._getResource(property));","\t\tif(!statements.length) return false;","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push(statements[i].object.termType == \"literal\" ? statements[i].object.toString() : statements[i].object);","\t\t}","\t\treturn returnArray;","\t},","\t","\t/**","\t * Gets statements matching a certain pattern","\t *","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tsubj \t\tSubject","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tpredicate\tPredicate","\t * @param\t{String|Zotero.RDF.AJAW.Symbol}\tobj\t\t\tObject","\t * @param\t{Boolean}\t\t\t\t\t\t\tobjLiteral\tWhether the object is a literal (as","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topposed to a URI)","\t * @param\t{Boolean}\t\t\t\t\t\t\tjustOne\t\tWhether to stop when a single result is","\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tretrieved","\t */","\t\"getStatementsMatching\":function(subj, pred, obj, objLiteral, justOne) {","\t\tvar statements = this._dataStore.statementsMatching(","\t\t\t(subj ? this._getResource(subj) : undefined),","\t\t\t(pred ? this._getResource(pred) : undefined),","\t\t\t(obj ? (objLiteral ? objLiteral : this._getResource(obj)) : undefined),","\t\t\tundefined, justOne);","\t\tif(!statements.length) return false;","\t\t","\t\t","\t\tvar returnArray = [];","\t\tfor(var i=0; i<statements.length; i++) {","\t\t\treturnArray.push([statements[i].subject, statements[i].predicate, (statements[i].object.termType == \"literal\" ? statements[i].object.toString() : statements[i].object)]);","\t\t}","\t\treturn returnArray;","\t}","};"],"id":18}],[{"start":{"row":0,"column":0},"end":{"row":159,"column":24},"action":"insert","lines":["width = verge.viewportW();","height = verge.viewportH();","","buildTess = function(width, height) {","  // var counter = 0;","  var svg;","  var path, path2, path3;","  var animate;","  var points = 50;","  var width = width,","    height = height;","  var vertices,","    vertices2,","    vertices3;","  var point = [1, 1];","  //setting x and y speed by % of viewport seems to give better performance then hard coded pixel amounts","  var xVelocity = width * 0.002;","  var yVelocity = height * 0.0025;","","  loadVertices(points);","","  function newVertices(points) {","    return d3.range(points).map(function(d) {","      return [Math.random() * width, Math.random() * height];","    });","  }","","  var voronoi = d3.geom.voronoi()","    .clipExtent([","      [0, 0],","      [width, height]","    ]);","","  function zoomView() {","    var points = vertices.length;","    var fontSize = parseInt($(\"div.top h1\").css(\"font-size\").split(\"px\")[0]);","    if (points >= 20) {","      points = points - 10;","      $(\"div.top h1\").css(\"font-size\", fontSize + 10);","    }","    loadVertices(points);","    render();","","  };","","  var drag = d3.behavior.drag()","    .on(\"dragstart\", function() {","      //clear auto calling animate when dragging begins","      clearInterval(animate);","    })","    .on(\"drag\", function() {","      //touch events","      touchXY = [d3.event.x, d3.event.y];","      point = touchXY;","      render();","    })","    .on(\"dragend\", function() {","      animate = setInterval(function() {","        render();","      }, 5);","    })","","  svg = d3.select(\"#chart\").append(\"svg\")","    .attr(\"width\", width)","    .attr(\"height\", height)","    //remove the following listeners if you simply want animation and no interaction ","    .on(\"mousemove\", function() {","      //stop calling animate when mouse takes control","      clearInterval(animate);","      var mouseXY = d3.mouse(this);","      point = mouseXY;","      render();","    })","    .on(\"click\", function() {","      var mouseXY = [d3.event.x, d3.event.y];","      point = mouseXY;","      //reduce number of nodes on screen to give illusion of zooming in","      zoomView(point);","    })","    .on('mouseleave', function() {","      //restart animation after mouse lives viewport","      animate = setInterval(function() {","        render();","      }, 5);","    })","    .call(drag);","","  path = svg.append(\"g\").selectAll(\"path\");","  path2 = svg.append(\"g\").selectAll(\"path\");","  path3 = svg.append(\"g\").selectAll(\"path\");","","  svg.append(\"rect\")","    .attr(\"width\", width)","    .attr(\"height\", height);","","  //kick off continuous animation... raising the interval will  trigger the browser to paint and actually reduce performance","  animate = setInterval(function() {","    render();","  }, 5);","","  function render() {","    var crntX = point[0];","    var crntY = point[1];","    var newX, newY;","    //if moving point is at the right or left edges switch x direction","    if (crntX >= width || crntX <= 0) {","      xVelocity *= -1;","    }","    //if moving point is at the top or bottom edges switch y direction","    if (crntY >= height || crntY <= 0) {","      yVelocity *= -1;","    }","","    newX = crntX + xVelocity;","    newY = crntY + yVelocity;","","    redraw([newX, newY]);","    point = [newX, newY];","","  }","","  function loadVertices(points) {","    vertices = newVertices(points);","    vertices2 = newVertices(points);","    vertices3 = newVertices(points);","  };","","  function redraw(mouseXY) {","    vertices[0] = mouseXY;","    path = path.data(voronoi(vertices), polygon);","    path.exit().remove();","    path.enter().append(\"path\")","      .attr(\"d\", polygon);","    path.order();","","    vertices2[0] = mouseXY;","    path2 = path2.data(voronoi(vertices2), polygon);","    path2.exit().remove();","    path2.enter().append(\"path\")","      .attr(\"d\", polygon);","    path2.order();","","    vertices3[0] = mouseXY;","    path3 = path3.data(voronoi(vertices3), polygon);","    path3.exit().remove();","    path3.enter().append(\"path\")","      .attr(\"d\", polygon);","    path3.order();","  }","","  function polygon(d) {","    return \"M\" + d.join(\"L\") + \"Z\";","  }","","  function getRandom() {","    return Math.random() * (10 - 3) + 3;","  }","};","","buildTess(width, height)"],"id":19}],[{"start":{"row":0,"column":6},"end":{"row":0,"column":7},"action":"remove","lines":["="],"id":25}],[{"start":{"row":0,"column":6},"end":{"row":0,"column":7},"action":"insert","lines":[":"],"id":26}],[{"start":{"row":0,"column":6},"end":{"row":0,"column":7},"action":"remove","lines":[":"],"id":27}],[{"start":{"row":0,"column":5},"end":{"row":0,"column":6},"action":"remove","lines":[" "],"id":28}],[{"start":{"row":0,"column":5},"end":{"row":0,"column":6},"action":"insert","lines":[":"],"id":29}],[{"start":{"row":0,"column":5},"end":{"row":0,"column":6},"action":"remove","lines":[":"],"id":30}],[{"start":{"row":0,"column":5},"end":{"row":0,"column":6},"action":"insert","lines":[" "],"id":31}],[{"start":{"row":0,"column":6},"end":{"row":0,"column":7},"action":"insert","lines":["="],"id":32}],[{"start":{"row":0,"column":0},"end":{"row":159,"column":24},"action":"remove","lines":["width = verge.viewportW();","height = verge.viewportH();","","buildTess = function(width, height) {","  // var counter = 0;","  var svg;","  var path, path2, path3;","  var animate;","  var points = 50;","  var width = width,","    height = height;","  var vertices,","    vertices2,","    vertices3;","  var point = [1, 1];","  //setting x and y speed by % of viewport seems to give better performance then hard coded pixel amounts","  var xVelocity = width * 0.002;","  var yVelocity = height * 0.0025;","","  loadVertices(points);","","  function newVertices(points) {","    return d3.range(points).map(function(d) {","      return [Math.random() * width, Math.random() * height];","    });","  }","","  var voronoi = d3.geom.voronoi()","    .clipExtent([","      [0, 0],","      [width, height]","    ]);","","  function zoomView() {","    var points = vertices.length;","    var fontSize = parseInt($(\"div.top h1\").css(\"font-size\").split(\"px\")[0]);","    if (points >= 20) {","      points = points - 10;","      $(\"div.top h1\").css(\"font-size\", fontSize + 10);","    }","    loadVertices(points);","    render();","","  };","","  var drag = d3.behavior.drag()","    .on(\"dragstart\", function() {","      //clear auto calling animate when dragging begins","      clearInterval(animate);","    })","    .on(\"drag\", function() {","      //touch events","      touchXY = [d3.event.x, d3.event.y];","      point = touchXY;","      render();","    })","    .on(\"dragend\", function() {","      animate = setInterval(function() {","        render();","      }, 5);","    })","","  svg = d3.select(\"#chart\").append(\"svg\")","    .attr(\"width\", width)","    .attr(\"height\", height)","    //remove the following listeners if you simply want animation and no interaction ","    .on(\"mousemove\", function() {","      //stop calling animate when mouse takes control","      clearInterval(animate);","      var mouseXY = d3.mouse(this);","      point = mouseXY;","      render();","    })","    .on(\"click\", function() {","      var mouseXY = [d3.event.x, d3.event.y];","      point = mouseXY;","      //reduce number of nodes on screen to give illusion of zooming in","      zoomView(point);","    })","    .on('mouseleave', function() {","      //restart animation after mouse lives viewport","      animate = setInterval(function() {","        render();","      }, 5);","    })","    .call(drag);","","  path = svg.append(\"g\").selectAll(\"path\");","  path2 = svg.append(\"g\").selectAll(\"path\");","  path3 = svg.append(\"g\").selectAll(\"path\");","","  svg.append(\"rect\")","    .attr(\"width\", width)","    .attr(\"height\", height);","","  //kick off continuous animation... raising the interval will  trigger the browser to paint and actually reduce performance","  animate = setInterval(function() {","    render();","  }, 5);","","  function render() {","    var crntX = point[0];","    var crntY = point[1];","    var newX, newY;","    //if moving point is at the right or left edges switch x direction","    if (crntX >= width || crntX <= 0) {","      xVelocity *= -1;","    }","    //if moving point is at the top or bottom edges switch y direction","    if (crntY >= height || crntY <= 0) {","      yVelocity *= -1;","    }","","    newX = crntX + xVelocity;","    newY = crntY + yVelocity;","","    redraw([newX, newY]);","    point = [newX, newY];","","  }","","  function loadVertices(points) {","    vertices = newVertices(points);","    vertices2 = newVertices(points);","    vertices3 = newVertices(points);","  };","","  function redraw(mouseXY) {","    vertices[0] = mouseXY;","    path = path.data(voronoi(vertices), polygon);","    path.exit().remove();","    path.enter().append(\"path\")","      .attr(\"d\", polygon);","    path.order();","","    vertices2[0] = mouseXY;","    path2 = path2.data(voronoi(vertices2), polygon);","    path2.exit().remove();","    path2.enter().append(\"path\")","      .attr(\"d\", polygon);","    path2.order();","","    vertices3[0] = mouseXY;","    path3 = path3.data(voronoi(vertices3), polygon);","    path3.exit().remove();","    path3.enter().append(\"path\")","      .attr(\"d\", polygon);","    path3.order();","  }","","  function polygon(d) {","    return \"M\" + d.join(\"L\") + \"Z\";","  }","","  function getRandom() {","    return Math.random() * (10 - 3) + 3;","  }","};","","buildTess(width, height)"],"id":33},{"start":{"row":0,"column":0},"end":{"row":190,"column":22},"action":"insert","lines":["// Interesting fact! These are not more colorful when moving, that is an optical illusion.","","// requestAnimFrame() As explained by Mr Irish: http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/","window.requestAnimFrame = (function(){","  return  window.requestAnimationFrame ||","    window.webkitRequestAnimationFrame ||","    window.mozRequestAnimationFrame    ||","    window.oRequestAnimationFrame      ||","    window.msRequestAnimationFrame     ||","    function( callback ){","    window.setTimeout(callback, 1000 / 60);","  };","})();","","var starfield = (function() {","  // Variables - a quantity which during a calculation is assumed to vary or be capable of varying in value","  var stars = [],","      star_density = 25,","      velocity = {x:0, y: 0},","      star_colors = [\"rgba(0,0,0,.5)\", \"#ffe9c4\", \"#d4fbff\"],","      stars_bg = \"rgba(0,0,0,.5)\",","      frame,","      star_canvas,","      star_context,","      viewport_width,","      viewport_height; ","","  function initialize() {","    // Make canvas","    star_canvas = document.createElement('canvas');","    star_context = star_canvas.getContext('2d');","","    // Get viewport size and resize canvas","    resize_canvas();","       ","    // Draw all the stars, I decided stars come in units of 10 ","    for (var i = 0; i < (star_density*10); i++) {","      var rad = Math.random() * 2;","      create_star(rad);","      // twice as many small stars as big","      var rad = Math.random();","      create_star(rad);","      create_star(rad);","    }","   ","    // Put the canvas on the page","    document.body.appendChild(star_canvas);","    ","    // When you press keys stuff happens ","    document.addEventListener('keydown', function(e) {","      e = e || window.event;","      // We add to the existing velocity, this dampens the speed changes and makes changing directions more gradual just like flying a real spaceship... I imagine","      if (e.keyCode == 39) {","        velocity = {","          x: velocity.x -5, ","          y: velocity.y","        };","      }","      if (e.keyCode == 37) {","        velocity = {","          x: velocity.x +5, ","          y: velocity.y","        };","      }","      if (e.keyCode == 40) {","        velocity = {","          x: velocity.x, ","          y: velocity.y -5","        };","      }","      if (e.keyCode == 38) {","        velocity = {","          x: velocity.x,","          y: velocity.y +5","        };","      }","    }, false);","    ","    // Drawing our first frame starts the drawing loop","    draw_frame();","","    function clear_canvas() {","      // Each frame the canvas is painted wiht semi transparent black - this gives the trail effect behind moving stars","      star_context.fillStyle=stars_bg;","      star_context.fillRect(0, 0, viewport_width, viewport_height);","      ","    }","","    function draw_star() {","      var s = stars.length;","      // for every star","      while(s--) {","        var star = stars[s];","        // update individual stars position","        star.update();","        // render the star to the canvas","        star.render(star_context);","      }","    }","","","    function create_star(rad) {","      // I don't really need a function for create_star, but reads better and easy to expand upon","      stars.push(new star(rad));","    }","","    function draw_frame() {","      clear_canvas();","      // The infinate loop!","      frame = requestAnimFrame(draw_frame);","      draw_star();","    }","","  }","","  function resize_canvas(){","    viewport_width = window.innerWidth;","    viewport_height = window.innerHeight;","    star_canvas.width = viewport_width;","    star_canvas.height = viewport_height;","  }","","","  var star = function(rad) {","    ","    this.alpha    = Math.round((Math.random() * 100 - 70) + 70); // Random brightness","    this.radius = rad || Math.random() * 2; // Radius","    this.color    = star_colors[Math.round(Math.random() * star_colors.length)]; // Random color from array","","    this.pos = {","      // Initial random position","      x: Math.random() * viewport_width, ","      y: Math.random() * viewport_height","    };","","","  };","","  star.prototype = {","","    update: function() {","","      // Depending on the radius the star will move at a differnt speed (slower where a greater perception of depth) ","      // Yes! 3 is a magic number :)","      this.pos.y += velocity.y === 0 ? velocity.y : (velocity.y / (3 - this.radius));","      this.pos.x += velocity.x === 0 ? velocity.x : (velocity.x / (3 - this.radius));","      ","      // Keep the stars on the canvas","      if(this.pos.y > viewport_height){","        this.pos.y = 0;        ","      } else if(this.pos.y < 0){","        this.pos.y = viewport_height;","      }","      // Keep the stars on the canvas in a different direction","      if(this.pos.x > viewport_width){","        this.pos.x = 0;        ","      } else if(this.pos.x < 0){","        this.pos.x = viewport_width;        ","      }","      // Dampen the velocity, ie slow down when you stop telling it to move","      velocity.x = velocity.x /1.00005;","      velocity.y = velocity.y /1.00005;","    },","","    render: function(context) {","      // Draw the star at its current position","      var x = Math.round(this.pos.x),","          y = Math.round(this.pos.y);","","      context.save();","      context.globalCompositeOperation = 'lighter';","      context.globalAlpha = this.alpha;      ","      context.fillStyle = this.color;","      context.beginPath();","      context.moveTo(x, y);","      context.arc(x, y, this.radius, 0, Math.PI * 2, true);","      context.closePath();","      context.fill();","      context.restore();","    }","","  };","  ","  return {","    // Always kick things off with a really cool function name!","    lets_roll: initialize","  };","  ","})();","","starfield.lets_roll();"]}],[{"start":{"row":0,"column":0},"end":{"row":2,"column":120},"action":"remove","lines":["// Interesting fact! These are not more colorful when moving, that is an optical illusion.","","// requestAnimFrame() As explained by Mr Irish: http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/"],"id":34}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":35}],[{"start":{"row":1,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["",""],"id":36}],[{"start":{"row":0,"column":0},"end":{"row":0,"column":48},"action":"insert","lines":["setInterval(function () {alert(\"Hello\")}, 3000);"],"id":37}],[{"start":{"row":0,"column":0},"end":{"row":0,"column":3},"action":"insert","lines":["// "],"id":38}],[{"start":{"row":0,"column":0},"end":{"row":0,"column":51},"action":"remove","lines":["// setInterval(function () {alert(\"Hello\")}, 3000);"],"id":39},{"start":{"row":0,"column":0},"end":{"row":3,"column":8},"action":"insert","lines":["setInterval(function(){","     $(\"#box2\").is(\":visible\") ? $(\"#box2\").hide() : $(\"#box2\").show();","    $(\"#box1\").is(\":visible\") ? $(\"#box1\").hide() : $(\"#box1\").show();","},3000);"]}],[{"start":{"row":0,"column":0},"end":{"row":3,"column":8},"action":"remove","lines":["setInterval(function(){","     $(\"#box2\").is(\":visible\") ? $(\"#box2\").hide() : $(\"#box2\").show();","    $(\"#box1\").is(\":visible\") ? $(\"#box1\").hide() : $(\"#box1\").show();","},3000);"],"id":40}]],"mark":24,"position":24},"ace":{"folds":[],"scrolltop":1073,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":190,"column":22},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":true,"wrapToView":true},"firstLineState":{"row":116,"state":"start","mode":"ace/mode/javascript"}},"timestamp":1431965815778,"hash":"8e4abb940b7db33af65379dd62e6187c1c58e681"}